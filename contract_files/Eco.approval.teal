#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 3 4 1000000
    bytecblock "eco_token" "next_plot" "plot_count" 0x "eco_lp_token" "plot_cost" "plot_reward_rate" "pool_logicsig_template" "tinyman_router" 0x30313233343536373839 "ECO" 0x151f7c75 0x506c6f7420233a20 "PLOT"
    txn ApplicationID
    bnz main_after_if_else@2
    // contract.py:48
    // self.eco_token = UInt64(0)
    bytec_0 // "eco_token"
    intc_0 // 0
    app_global_put
    // contract.py:49
    // self.eco_token_created = False
    pushbytes "eco_token_created"
    intc_0 // 0
    app_global_put
    // contract.py:50
    // self.eco_lp_token = UInt64(0)
    bytec 4 // "eco_lp_token"
    intc_0 // 0
    app_global_put
    // contract.py:51
    // self.plot_count = UInt64(1)
    bytec_2 // "plot_count"
    intc_1 // 1
    app_global_put
    // contract.py:52
    // self.next_plot = UInt64(0)
    bytec_1 // "next_plot"
    intc_0 // 0
    app_global_put
    // contract.py:53
    // self.plot_cost = UInt64(10_000)
    bytec 5 // "plot_cost"
    pushint 10000 // 10000
    app_global_put
    // contract.py:54
    // self.plot_reward_rate = UInt64(1_000_000)
    bytec 6 // "plot_reward_rate"
    intc 4 // 1000000
    app_global_put
    // contract.py:55
    // self.pool_logicsig_template = op.base64_decode(op.Base64.StdEncoding, b"BoAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgQBbNQA0ADEYEkQxGYEBEkSBAUM=")
    pushbytes 0x426f41594141414141414141414141414141414141414141414141414141414141414141675142624e51413041444559456b517847594542456b534241554d3d
    base64_decode StdEncoding
    bytec 7 // "pool_logicsig_template"
    swap
    app_global_put
    // contract.py:56
    // self.tinyman_router = Application(148607000) #testnet
    bytec 8 // "tinyman_router"
    pushint 148607000 // 148607000
    app_global_put

main_after_if_else@2:
    // contract.py:46
    // class Eco(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x47e77c38 0x6f9911fd 0x71351241 0x7cce9f1f // method "mint_eco(txn)uint64", method "bootstrap_via_outer_and_add_initial_liquidity(txn)void", method "mint_plot(txn,txn)void", method "claim_plot_rewards()uint64"
    txna ApplicationArgs 0
    match mint_eco bootstrap_via_outer_and_add_initial_liquidity mint_plot claim_plot_rewards
    err

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contract.is_creator() -> void:
is_creator:
    // contract.py:6
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    retsub


// contract.contract_is_receiver(txn: uint64) -> void:
contract_is_receiver:
    // contract.py:12-13
    // @subroutine
    // def contract_is_receiver(txn: gtxn.Transaction) -> None:
    proto 1 0
    // contract.py:14
    // assert txn.type in (TransactionType.Payment, TransactionType.AssetTransfer)
    frame_dig -1
    gtxns TypeEnum
    dup
    intc_1 // pay
    ==
    dup
    bnz contract_is_receiver_bool_true@2
    frame_dig 0
    intc_3 // axfer
    ==
    bz contract_is_receiver_bool_false@3

contract_is_receiver_bool_true@2:
    intc_1 // 1

contract_is_receiver_bool_merge@4:
    // contract.py:14
    // assert txn.type in (TransactionType.Payment, TransactionType.AssetTransfer)
    assert
    // contract.py:15
    // if txn.type == TransactionType.Payment:
    frame_dig 1
    bz contract_is_receiver_else_body@6
    // contract.py:16
    // assert txn.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    retsub

contract_is_receiver_else_body@6:
    // contract.py:18
    // assert txn.asset_receiver == Global.current_application_address
    frame_dig -1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    retsub

contract_is_receiver_bool_false@3:
    intc_0 // 0
    b contract_is_receiver_bool_merge@4


// contract.refund_excess_mbr(pre_mbr: uint64, post_mbr: uint64, mbr_payment: uint64) -> void:
refund_excess_mbr:
    // contract.py:24-25
    // @subroutine
    // def refund_excess_mbr(pre_mbr: UInt64, post_mbr: UInt64, mbr_payment: gtxn.Transaction) -> None:
    proto 3 0
    // contract.py:26
    // mbr_used = post_mbr - pre_mbr
    frame_dig -2
    frame_dig -3
    -
    // contract.py:27
    // excess = mbr_payment.amount - mbr_used
    frame_dig -1
    gtxns Amount
    swap
    -
    // contract.py:28-31
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_begin
    // contract.py:29
    // receiver=Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // contract.py:28
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:28-31
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_submit
    retsub


// contract.itoa(i: uint64) -> bytes:
itoa:
    // contract.py:33-34
    // @subroutine
    // def itoa(i: UInt64) -> Bytes:
    proto 1 1
    // contract.py:37
    // if i < radix:
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:37
    // if i < radix:
    <
    bz itoa_after_if_else@2
    // contract.py:35
    // digits = Bytes(b"0123456789")
    bytec 9 // 0x30313233343536373839
    // contract.py:38
    // return digits[i]
    frame_dig -1
    intc_1 // 1
    extract3
    retsub

itoa_after_if_else@2:
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    /
    callsub itoa
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    %
    // contract.py:35
    // digits = Bytes(b"0123456789")
    bytec 9 // 0x30313233343536373839
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    swap
    intc_1 // 1
    extract3
    concat
    retsub


// contract.Eco.mint_eco[routing]() -> void:
mint_eco:
    // contract.py:58
    // @abimethod
    txn GroupIndex
    intc_1 // 1
    -
    // contract.py:60
    // is_creator()
    callsub is_creator
    // contract.py:61
    // contract_is_receiver(mbr_payment)
    dup
    callsub contract_is_receiver
    // contract.py:22
    // assert txn.type == TransactionType.Payment
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:65-73
    // create_eco_txn = itxn.AssetConfig(
    //     asset_name='ECO',
    //     unit_name='ECO',
    //     total=UInt64((2**64) - 1),
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:70
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:71
    // reserve=Global.current_application_address,
    dup
    // contract.py:72
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:69
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:68
    // total=UInt64((2**64) - 1),
    pushint 18446744073709551615 // 18446744073709551615
    itxn_field ConfigAssetTotal
    // contract.py:67
    // unit_name='ECO',
    bytec 10 // "ECO"
    itxn_field ConfigAssetUnitName
    // contract.py:66
    // asset_name='ECO',
    bytec 10 // "ECO"
    itxn_field ConfigAssetName
    // contract.py:65
    // create_eco_txn = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:65-73
    // create_eco_txn = itxn.AssetConfig(
    //     asset_name='ECO',
    //     unit_name='ECO',
    //     total=UInt64((2**64) - 1),
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    // contract.py:76
    // self.eco_token = create_eco_txn.created_asset.id
    bytec_0 // "eco_token"
    itxn CreatedAssetID
    app_global_put
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:85
    // refund_excess_mbr(pre_mbr, post_mbr, mbr_payment)
    uncover 2
    callsub refund_excess_mbr
    // contract.py:86
    // return self.eco_token
    intc_0 // 0
    bytec_0 // "eco_token"
    app_global_get_ex
    assert // check self.eco_token exists
    // contract.py:58
    // @abimethod
    itob
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.Eco.bootstrap_via_outer_and_add_initial_liquidity[routing]() -> void:
bootstrap_via_outer_and_add_initial_liquidity:
    bytec_3 // ""
    dup
    // contract.py:91
    // @abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    // contract.py:98
    // is_creator()
    callsub is_creator
    // contract.py:99
    // contract_is_receiver(mbr_payment)
    dup
    callsub contract_is_receiver
    // contract.py:22
    // assert txn.type == TransactionType.Payment
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:262
    // program_bytes = self.pool_logicsig_template
    intc_0 // 0
    bytec 7 // "pool_logicsig_template"
    app_global_get_ex
    assert // check self.pool_logicsig_template exists
    // contract.py:265
    // program_bytes[0:3] +
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 3
    dig 2
    >=
    intc_2 // 3
    dig 3
    uncover 2
    select
    dig 3
    cover 2
    substring3
    // contract.py:266
    // arc4.UInt64(self.tinyman_router.id).bytes +
    intc_0 // 0
    bytec 8 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    dup
    itob
    // contract.py:265-266
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    uncover 2
    swap
    concat
    // contract.py:267
    // arc4.UInt64(self.eco_token).bytes +
    intc_0 // 0
    bytec_0 // "eco_token"
    app_global_get_ex
    assert // check self.eco_token exists
    dup
    itob
    // contract.py:265-267
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    uncover 2
    swap
    concat
    // contract.py:268
    // arc4.UInt64(0).bytes +
    pushbytes 0x0000000000000000
    // contract.py:265-268
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    // arc4.UInt64(0).bytes +
    concat
    // contract.py:269
    // program_bytes[27:]
    pushint 27 // 27
    dig 4
    >=
    pushint 27 // 27
    dig 5
    uncover 2
    select
    uncover 5
    swap
    uncover 5
    substring3
    // contract.py:265-269
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    // arc4.UInt64(0).bytes +
    // program_bytes[27:]
    concat
    // contract.py:272
    // return Account.from_bytes(op.sha512_256(b'Program' + program_bytes))
    pushbytes 0x50726f6772616d
    swap
    concat
    sha512_256
    // contract.py:162
    // LP_token_id = Asset(op.AppLocal.get_ex_uint64(pool_address, self.tinyman_router, b'pool_token_asset_id')[0])
    dup
    dig 3
    pushbytes 0x706f6f6c5f746f6b656e5f61737365745f6964
    app_local_get_ex
    pop
    // contract.py:146
    // optin_lp = itxn.AssetTransfer(xfer_asset=LP_token, asset_receiver=Global.current_application_address)
    global CurrentApplicationAddress
    // contract.py:157
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_begin
    itxn_field AssetReceiver
    dup
    itxn_field XferAsset
    // contract.py:146
    // optin_lp = itxn.AssetTransfer(xfer_asset=LP_token, asset_receiver=Global.current_application_address)
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:157
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    // contract.py:147
    // transfer_asset = itxn.AssetTransfer(xfer_asset=self.eco_token, asset_receiver=pool_address, asset_amount=2**64 // 2)
    pushint 9223372036854775808 // 9223372036854775808
    itxn_field AssetAmount
    dig 1
    itxn_field AssetReceiver
    uncover 2
    itxn_field XferAsset
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:157
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    // contract.py:148
    // transfer_algo = itxn.Payment(receiver=pool_address, amount=1_000_000)
    intc 4 // 1000000
    itxn_field Amount
    dig 1
    itxn_field Receiver
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:157
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    swap
    itxn_field Accounts
    dup
    itxn_field Assets
    // contract.py:149
    // tiny_args = Bytes(b'add_initial_liquidity')
    pushbytes 0x6164645f696e697469616c5f6c6971756964697479
    itxn_field ApplicationArgs
    // contract.py:152
    // on_completion=OnCompleteAction.NoOp,
    intc_0 // NoOp
    itxn_field OnCompletion
    swap
    itxn_field ApplicationID
    // contract.py:150
    // add_lp_call = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:157
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_submit
    // contract.py:105-106
    // # self.is_bootstrapping(pool_address, bootstrap_fee, bootstrap_tx)
    // self.eco_lp_token = self.add_initial_liquidity(pool_address)
    bytec 4 // "eco_lp_token"
    swap
    app_global_put
    // contract.py:167
    // plot_count_as_string = itoa(self.plot_count)
    intc_0 // 0
    bytec_2 // "plot_count"
    app_global_get_ex
    assert // check self.plot_count exists
    callsub itoa
    dup
    // contract.py:168
    // plot_count_with_commas = Bytes(b'')
    bytec_3 // 0x
    swap
    // contract.py:170
    // if plot_count_as_string.length <= 3:
    len
    dup
    intc_2 // 3
    <=
    bz bootstrap_via_outer_and_add_initial_liquidity_else_body@7
    dig 2
    bury 2

bootstrap_via_outer_and_add_initial_liquidity_after_if_else@13:
    // contract.py:181-189
    // create_initial_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:182
    // asset_name=b'Plot #: ' + plot_count_with_commas,
    bytec 12 // 0x506c6f7420233a20
    dig 2
    concat
    // contract.py:186
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:187
    // reserve=Global.current_application_address,
    dup
    // contract.py:188
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:185
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:184
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // contract.py:183
    // unit_name='PLOT',
    bytec 13 // "PLOT"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // contract.py:181
    // create_initial_plot = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:181-189
    // create_initial_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    // contract.py:108
    // self.next_plot = self.mint_initial_plot()
    bytec_1 // "next_plot"
    itxn CreatedAssetID
    app_global_put
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:110
    // post_mbr = get_mbr() + 1_000_000 # Add 1 Algo for the initial liquidity add fee
    intc 4 // 1000000
    +
    // contract.py:111
    // refund_excess_mbr(pre_mbr, post_mbr, mbr_payment)
    dig 4
    swap
    dig 6
    callsub refund_excess_mbr
    // contract.py:91
    // @abimethod
    intc_1 // 1
    return

bootstrap_via_outer_and_add_initial_liquidity_else_body@7:
    // contract.py:173
    // cursor = UInt64(0)
    intc_0 // 0
    bury 7
    // contract.py:174
    // for i in urange(plot_count_as_string.length):
    intc_0 // 0
    bury 6

bootstrap_via_outer_and_add_initial_liquidity_for_header@8:
    // contract.py:174
    // for i in urange(plot_count_as_string.length):
    dig 5
    dig 1
    <
    bz bootstrap_via_outer_and_add_initial_liquidity_after_if_else@13
    // contract.py:175
    // cursor += 1
    dig 6
    intc_1 // 1
    +
    dup
    bury 8
    // contract.py:176
    // if cursor == 3:
    intc_2 // 3
    ==
    bz bootstrap_via_outer_and_add_initial_liquidity_after_if_else@11
    // contract.py:177
    // plot_count_with_commas = plot_count_with_commas + b','
    dig 1
    pushbytes 0x2c
    concat
    bury 2
    // contract.py:178
    // cursor = UInt64(0)
    intc_0 // 0
    bury 7

bootstrap_via_outer_and_add_initial_liquidity_after_if_else@11:
    // contract.py:179
    // plot_count_with_commas = plot_count_with_commas + plot_count_as_string[i]
    dig 2
    dig 6
    dup
    cover 2
    intc_1 // 1
    extract3
    dig 3
    swap
    concat
    bury 3
    // contract.py:174
    // for i in urange(plot_count_as_string.length):
    intc_1 // 1
    +
    bury 6
    b bootstrap_via_outer_and_add_initial_liquidity_for_header@8


// contract.Eco.mint_plot[routing]() -> void:
mint_plot:
    intc_0 // 0
    dup
    bytec_3 // ""
    dupn 2
    // contract.py:193
    // @abimethod
    txn GroupIndex
    pushint 2 // 2
    -
    txn GroupIndex
    intc_1 // 1
    -
    dup
    cover 2
    // contract.py:195
    // contract_is_receiver(plot_payment)
    dig 1
    callsub contract_is_receiver
    // contract.py:196
    // contract_is_receiver(mbr_payment)
    dup
    callsub contract_is_receiver
    // contract.py:22
    // assert txn.type == TransactionType.Payment
    dig 1
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    // contract.py:244
    // assert txn.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contract.py:245
    // assert txn.amount == self.plot_cost
    gtxns Amount
    intc_0 // 0
    bytec 5 // "plot_cost"
    app_global_get_ex
    assert // check self.plot_cost exists
    ==
    assert
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:249
    // users_plots = Box(Bytes, key=b'p' + Txn.sender.bytes) # p prefix for plots
    pushbytes 0x70
    txn Sender
    concat
    dup
    // contract.py:250
    // plot_info = PlotInfo(plot_id=arc4.UInt64(self.next_plot), plot_last_claim_time=arc4.UInt64(Global.latest_timestamp))
    intc_0 // 0
    bytec_1 // "next_plot"
    app_global_get_ex
    assert // check self.next_plot exists
    itob
    global LatestTimestamp
    itob
    concat
    cover 2
    // contract.py:251
    // if users_plots:
    box_len
    bury 1
    bz mint_plot_else_body@15
    // contract.py:252
    // initial_box_length = users_plots.length
    dup
    box_len
    assert // check Box exists
    // contract.py:253
    // users_plots.resize(initial_box_length + 16)
    dup
    pushint 16 // 16
    +
    dig 2
    swap
    box_resize
    // contract.py:254
    // users_plots.splice(initial_box_length, 16, plot_info.bytes)
    pushint 16 // 16
    dig 3
    box_splice

mint_plot_after_if_else@16:
    // contract.py:204
    // self.plot_count += 1
    intc_0 // 0
    bytec_2 // "plot_count"
    app_global_get_ex
    assert // check self.plot_count exists
    intc_1 // 1
    +
    bytec_2 // "plot_count"
    dig 1
    app_global_put
    // contract.py:206
    // plot_count_as_string = itoa(self.plot_count)
    callsub itoa
    dup
    bury 9
    // contract.py:207
    // plot_count_with_commas = Bytes(b'')
    bytec_3 // 0x
    bury 8
    // contract.py:209
    // if plot_count_as_string.length <= 3:
    len
    dup
    bury 5
    intc_2 // 3
    <=
    bz mint_plot_else_body@3
    dig 7
    bury 7

mint_plot_after_if_else@10:
    // contract.py:220-228
    // create_next_users_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:221
    // asset_name=b'Plot #: ' + plot_count_with_commas,
    bytec 12 // 0x506c6f7420233a20
    dig 7
    concat
    // contract.py:225
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:226
    // reserve=Global.current_application_address,
    dup
    // contract.py:227
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:224
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:223
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // contract.py:222
    // unit_name='PLOT',
    bytec 13 // "PLOT"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // contract.py:220
    // create_next_users_plot = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:220-228
    // create_next_users_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // contract.py:231-235
    // itxn.AssetTransfer(
    //     asset_amount=1,
    //     asset_receiver=Txn.sender,
    //     xfer_asset=self.next_plot,
    // ).submit()
    itxn_begin
    // contract.py:233
    // asset_receiver=Txn.sender,
    txn Sender
    // contract.py:234
    // xfer_asset=self.next_plot,
    intc_0 // 0
    bytec_1 // "next_plot"
    app_global_get_ex
    assert // check self.next_plot exists
    itxn_field XferAsset
    itxn_field AssetReceiver
    // contract.py:232
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    // contract.py:231
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:231-235
    // itxn.AssetTransfer(
    //     asset_amount=1,
    //     asset_receiver=Txn.sender,
    //     xfer_asset=self.next_plot,
    // ).submit()
    itxn_submit
    // contract.py:237
    // self.next_plot = create_next_users_plot.created_asset.id
    bytec_1 // "next_plot"
    swap
    app_global_put
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:240
    // refund_excess_mbr(pre_mbr, post_mbr, mbr_payment)
    dig 2
    swap
    dig 4
    callsub refund_excess_mbr
    // contract.py:193
    // @abimethod
    intc_1 // 1
    return

mint_plot_else_body@3:
    // contract.py:212
    // cursor = UInt64(0)
    intc_0 // 0
    bury 6
    // contract.py:213
    // for i in urange(plot_count_as_string.length):
    intc_0 // 0
    bury 5

mint_plot_for_header@4:
    // contract.py:213
    // for i in urange(plot_count_as_string.length):
    dig 4
    dig 4
    <
    bz mint_plot_after_if_else@10
    // contract.py:214
    // cursor += 1
    dig 5
    intc_1 // 1
    +
    dup
    bury 7
    // contract.py:215
    // if cursor == 3:
    intc_2 // 3
    ==
    bz mint_plot_after_if_else@7
    // contract.py:216
    // plot_count_with_commas = plot_count_with_commas + b','
    dig 6
    pushbytes 0x2c
    concat
    bury 7
    // contract.py:217
    // cursor = UInt64(0)
    intc_0 // 0
    bury 6

mint_plot_after_if_else@7:
    // contract.py:218
    // plot_count_with_commas = plot_count_with_commas + plot_count_as_string[i]
    dig 7
    dig 5
    dup
    cover 2
    intc_1 // 1
    extract3
    dig 8
    swap
    concat
    bury 8
    // contract.py:213
    // for i in urange(plot_count_as_string.length):
    intc_1 // 1
    +
    bury 5
    b mint_plot_for_header@4

mint_plot_else_body@15:
    // contract.py:257
    // users_plots.create(size=UInt64(16))
    dup
    pushint 16 // 16
    box_create
    pop
    // contract.py:258
    // users_plots.replace(0, plot_info.bytes)
    intc_0 // 0
    dig 2
    box_replace
    b mint_plot_after_if_else@16


// contract.Eco.claim_plot_rewards[routing]() -> void:
claim_plot_rewards:
    // contract.py:282
    // total_reward = UInt64(0)
    intc_0 // 0
    // contract.py:283
    // users_plots = Box(Bytes, key=b'p' + Txn.sender.bytes) # p prefix for plots
    pushbytes 0x70
    txn Sender
    concat
    dup
    // contract.py:284
    // for i in urange(users_plots.length // 16):
    box_len
    assert // check Box exists
    pushint 16 // 16
    /
    intc_0 // 0

claim_plot_rewards_for_header@2:
    // contract.py:284
    // for i in urange(users_plots.length // 16):
    dup
    dig 2
    <
    bz claim_plot_rewards_after_for@4
    // contract.py:285
    // individual_plot_bytes = users_plots.extract(i, i + 16)
    dupn 2
    pushint 16 // 16
    +
    dig 4
    dup
    cover 3
    dig 2
    uncover 2
    box_extract
    // contract.py:287
    // plot_reward = (Global.latest_timestamp - plot_info.plot_last_claim_time.as_uint64()) * self.plot_reward_rate
    global LatestTimestamp
    dig 1
    pushint 8 // 8
    extract_uint64
    -
    intc_0 // 0
    bytec 6 // "plot_reward_rate"
    app_global_get_ex
    assert // check self.plot_reward_rate exists
    *
    // contract.py:288
    // total_reward += plot_reward
    dig 7
    +
    bury 7
    // contract.py:289
    // plot_info.plot_last_claim_time = arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    replace2 8
    // contract.py:290
    // users_plots.splice(i + 8, 8, plot_info.bytes)
    dig 1
    pushint 8 // 8
    +
    uncover 3
    swap
    pushint 8 // 8
    uncover 3
    box_splice
    // contract.py:284
    // for i in urange(users_plots.length // 16):
    intc_1 // 1
    +
    bury 1
    b claim_plot_rewards_for_header@2

claim_plot_rewards_after_for@4:
    // contract.py:295-299
    // itxn.AssetTransfer(
    //     xfer_asset=self.eco_token,
    //     asset_amount=reward_amount,
    //     asset_receiver=Txn.sender
    // ).submit()
    itxn_begin
    // contract.py:296
    // xfer_asset=self.eco_token,
    intc_0 // 0
    bytec_0 // "eco_token"
    app_global_get_ex
    assert // check self.eco_token exists
    // contract.py:298
    // asset_receiver=Txn.sender
    txn Sender
    itxn_field AssetReceiver
    dig 4
    dup
    cover 2
    itxn_field AssetAmount
    itxn_field XferAsset
    // contract.py:295
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:295-299
    // itxn.AssetTransfer(
    //     xfer_asset=self.eco_token,
    //     asset_amount=reward_amount,
    //     asset_receiver=Txn.sender
    // ).submit()
    itxn_submit
    // contract.py:274
    // @abimethod
    itob
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
