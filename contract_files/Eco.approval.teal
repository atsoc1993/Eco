#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 3 1000000
    bytecblock "plot_count" "next_plot" 0x "eco_token" "eco_lp_token" "plot_cost" "pool_logicsig_template" "tinyman_router" 0x30313233343536373839 "ECO" 0x0000000000000000 0x506c6f7420233a20 "PLOT"
    txn ApplicationID
    bnz main_after_if_else@2
    // contract.py:48
    // self.eco_token = UInt64(0)
    bytec_3 // "eco_token"
    intc_0 // 0
    app_global_put
    // contract.py:49
    // self.eco_token_created = False
    pushbytes "eco_token_created"
    intc_0 // 0
    app_global_put
    // contract.py:50
    // self.eco_lp_token = UInt64(0)
    bytec 4 // "eco_lp_token"
    intc_0 // 0
    app_global_put
    // contract.py:51
    // self.plot_count = UInt64(10000) #testing commas, reset to 1
    bytec_0 // "plot_count"
    pushint 10000 // 10000
    app_global_put
    // contract.py:52
    // self.next_plot = UInt64(0)
    bytec_1 // "next_plot"
    intc_0 // 0
    app_global_put
    // contract.py:53
    // self.plot_cost = UInt64(1_000_000)
    bytec 5 // "plot_cost"
    intc_3 // 1000000
    app_global_put
    // contract.py:54
    // self.plot_reward_rate = UInt64(1_000_000)
    pushbytes "plot_reward_rate"
    intc_3 // 1000000
    app_global_put
    // contract.py:55
    // self.pool_logicsig_template = op.base64_decode(op.Base64.StdEncoding, b"BoAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgQBbNQA0ADEYEkQxGYEBEkSBAUM=")
    pushbytes 0x426f41594141414141414141414141414141414141414141414141414141414141414141675142624e51413041444559456b517847594542456b534241554d3d
    base64_decode StdEncoding
    bytec 6 // "pool_logicsig_template"
    swap
    app_global_put
    // contract.py:56
    // self.tinyman_router = Application(148607000) #testnet
    bytec 7 // "tinyman_router"
    pushint 148607000 // 148607000
    app_global_put

main_after_if_else@2:
    // contract.py:46
    // class Eco(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@11
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x8a2006de 0x71351241 // method "mint_eco(txn)void", method "mint_plot(txn,txn)void"
    txna ApplicationArgs 0
    match mint_eco mint_plot
    err

main___algopy_default_create@11:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contract.contract_is_receiver(txn: uint64) -> void:
contract_is_receiver:
    // contract.py:12-13
    // @subroutine
    // def contract_is_receiver(txn: gtxn.Transaction) -> None:
    proto 1 0
    // contract.py:14
    // assert txn.type in (TransactionType.Payment, TransactionType.AssetTransfer)
    frame_dig -1
    gtxns TypeEnum
    dup
    intc_1 // pay
    ==
    dup
    bnz contract_is_receiver_bool_true@2
    frame_dig 0
    pushint 4 // axfer
    ==
    bz contract_is_receiver_bool_false@3

contract_is_receiver_bool_true@2:
    intc_1 // 1

contract_is_receiver_bool_merge@4:
    // contract.py:14
    // assert txn.type in (TransactionType.Payment, TransactionType.AssetTransfer)
    assert
    // contract.py:15
    // if txn.type == TransactionType.Payment:
    frame_dig 1
    bz contract_is_receiver_else_body@6
    // contract.py:16
    // assert txn.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    retsub

contract_is_receiver_else_body@6:
    // contract.py:18
    // assert txn.asset_receiver == Global.current_application_address
    frame_dig -1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    retsub

contract_is_receiver_bool_false@3:
    intc_0 // 0
    b contract_is_receiver_bool_merge@4


// contract.refund_excess_mbr(pre_mbr: uint64, post_mbr: uint64, mbr_payment: uint64) -> void:
refund_excess_mbr:
    // contract.py:24-25
    // @subroutine
    // def refund_excess_mbr(pre_mbr: UInt64, post_mbr: UInt64, mbr_payment: gtxn.Transaction) -> None:
    proto 3 0
    // contract.py:26
    // mbr_used = post_mbr - pre_mbr
    frame_dig -2
    frame_dig -3
    -
    // contract.py:27
    // excess = mbr_payment.amount - mbr_used
    frame_dig -1
    gtxns Amount
    swap
    -
    // contract.py:28-31
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_begin
    // contract.py:29
    // receiver=Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // contract.py:28
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:28-31
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_submit
    retsub


// contract.itoa(i: uint64) -> bytes:
itoa:
    // contract.py:33-34
    // @subroutine
    // def itoa(i: UInt64) -> Bytes:
    proto 1 1
    // contract.py:37
    // if i < radix:
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:37
    // if i < radix:
    <
    bz itoa_after_if_else@2
    // contract.py:35
    // digits = Bytes(b"0123456789")
    bytec 8 // 0x30313233343536373839
    // contract.py:38
    // return digits[i]
    frame_dig -1
    intc_1 // 1
    extract3
    retsub

itoa_after_if_else@2:
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    /
    callsub itoa
    frame_dig -1
    // contract.py:36
    // radix = digits.length
    pushint 10 // 10
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    %
    // contract.py:35
    // digits = Bytes(b"0123456789")
    bytec 8 // 0x30313233343536373839
    // contract.py:40
    // return itoa(i // radix) + digits[i % radix]
    swap
    intc_1 // 1
    extract3
    concat
    retsub


// contract.Eco.mint_eco[routing]() -> void:
mint_eco:
    bytec_2 // ""
    dup
    // contract.py:58
    // @abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    // contract.py:6
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // contract.py:61
    // contract_is_receiver(mbr_payment)
    dup
    callsub contract_is_receiver
    // contract.py:22
    // assert txn.type == TransactionType.Payment
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:65-73
    // create_eco_txn = itxn.AssetConfig(
    //     asset_name='ECO',
    //     unit_name='ECO',
    //     total=UInt64((2**64) - 1),
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:70
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:71
    // reserve=Global.current_application_address,
    dup
    // contract.py:72
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:69
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:68
    // total=UInt64((2**64) - 1),
    pushint 18446744073709551615 // 18446744073709551615
    itxn_field ConfigAssetTotal
    // contract.py:67
    // unit_name='ECO',
    bytec 9 // "ECO"
    itxn_field ConfigAssetUnitName
    // contract.py:66
    // asset_name='ECO',
    bytec 9 // "ECO"
    itxn_field ConfigAssetName
    // contract.py:65
    // create_eco_txn = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:65-73
    // create_eco_txn = itxn.AssetConfig(
    //     asset_name='ECO',
    //     unit_name='ECO',
    //     total=UInt64((2**64) - 1),
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // contract.py:76
    // self.eco_token = create_eco_txn.created_asset.id
    bytec_3 // "eco_token"
    dig 1
    app_global_put
    // contract.py:229
    // program_bytes = self.pool_logicsig_template
    intc_0 // 0
    bytec 6 // "pool_logicsig_template"
    app_global_get_ex
    assert // check self.pool_logicsig_template exists
    // contract.py:232
    // program_bytes[0:3] +
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 3
    dig 2
    >=
    intc_2 // 3
    dig 3
    uncover 2
    select
    dig 3
    cover 2
    substring3
    // contract.py:233
    // arc4.UInt64(self.tinyman_router.id).bytes +
    intc_0 // 0
    bytec 7 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    dup
    itob
    // contract.py:232-233
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    uncover 2
    swap
    concat
    // contract.py:234
    // arc4.UInt64(self.eco_token).bytes +
    dig 4
    itob
    // contract.py:232-234
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    concat
    // contract.py:235
    // arc4.UInt64(0).bytes +
    bytec 10 // 0x0000000000000000
    // contract.py:232-235
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    // arc4.UInt64(0).bytes +
    concat
    // contract.py:236
    // program_bytes[27:]
    pushint 27 // 27
    dig 3
    >=
    pushint 27 // 27
    dig 4
    uncover 2
    select
    uncover 4
    swap
    uncover 4
    substring3
    // contract.py:232-236
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router.id).bytes +
    // arc4.UInt64(self.eco_token).bytes +
    // arc4.UInt64(0).bytes +
    // program_bytes[27:]
    concat
    // contract.py:239
    // return Account.from_bytes(op.sha512_256(b'Program' + program_bytes))
    pushbytes 0x50726f6772616d
    swap
    concat
    sha512_256
    // contract.py:103
    // rekey_to=self.tinyman_router.address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // contract.py:106
    // itxn.submit_txns(bootstrap_fee, bootstrap_app_call)
    itxn_begin
    // contract.py:94
    // amount=1_000_000
    intc_3 // 1000000
    itxn_field Amount
    dig 1
    itxn_field Receiver
    // contract.py:92
    // bootstrap_fee = itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:106
    // itxn.submit_txns(bootstrap_fee, bootstrap_app_call)
    itxn_next
    dig 3
    itxn_field Assets
    // contract.py:104
    // assets=(Asset(self.eco_token), Asset(0))
    intc_0 // 0
    itxn_field Assets
    itxn_field RekeyTo
    dup
    itxn_field Sender
    // contract.py:97
    // bootstrap_args = (Bytes(b'bootstrap'),)
    pushbytes 0x626f6f747374726170
    itxn_field ApplicationArgs
    // contract.py:100
    // on_completion=OnCompleteAction.OptIn,
    intc_1 // OptIn
    itxn_field OnCompletion
    dig 1
    itxn_field ApplicationID
    // contract.py:98
    // bootstrap_app_call = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:106
    // itxn.submit_txns(bootstrap_fee, bootstrap_app_call)
    itxn_submit
    // contract.py:127
    // LP_token_id = Asset(op.AppLocal.get_ex_uint64(pool_address, self.tinyman_router, b'pool_token_asset_id')[0])
    dup
    dig 2
    pushbytes 0x706f6f6c5f746f6b656e5f61737365745f6964
    app_local_get_ex
    pop
    // contract.py:111
    // optin_lp = itxn.AssetTransfer(xfer_asset=LP_token, asset_receiver=Global.current_application_address)
    global CurrentApplicationAddress
    // contract.py:122
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_begin
    itxn_field AssetReceiver
    dup
    itxn_field XferAsset
    // contract.py:111
    // optin_lp = itxn.AssetTransfer(xfer_asset=LP_token, asset_receiver=Global.current_application_address)
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:122
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    // contract.py:112
    // transfer_asset = itxn.AssetTransfer(xfer_asset=self.eco_token, asset_receiver=pool_address, asset_amount=2**64 // 2)
    pushint 9223372036854775808 // 9223372036854775808
    itxn_field AssetAmount
    dig 1
    itxn_field AssetReceiver
    uncover 3
    itxn_field XferAsset
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:122
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    // contract.py:113
    // transfer_algo = itxn.Payment(receiver=pool_address, amount=1_000_000)
    intc_3 // 1000000
    itxn_field Amount
    dig 1
    itxn_field Receiver
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:122
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_next
    swap
    itxn_field Accounts
    dup
    itxn_field Assets
    // contract.py:114
    // tiny_args = Bytes(b'add_initial_liquidity')
    pushbytes 0x6164645f696e697469616c5f6c6971756964697479
    itxn_field ApplicationArgs
    // contract.py:117
    // on_completion=OnCompleteAction.NoOp,
    intc_0 // NoOp
    itxn_field OnCompletion
    swap
    itxn_field ApplicationID
    // contract.py:115
    // add_lp_call = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:122
    // itxn.submit_txns(optin_lp, transfer_asset, transfer_algo, add_lp_call)
    itxn_submit
    // contract.py:80
    // self.eco_lp_token = self.add_initial_liquidity(pool_address)
    bytec 4 // "eco_lp_token"
    swap
    app_global_put
    // contract.py:132
    // plot_count_as_string = itoa(self.plot_count)
    intc_0 // 0
    bytec_0 // "plot_count"
    app_global_get_ex
    assert // check self.plot_count exists
    callsub itoa
    dup
    // contract.py:133
    // plot_count_with_commas = Bytes(b'')
    bytec_2 // 0x
    swap
    // contract.py:135
    // if plot_count_as_string.length <= 3:
    len
    dup
    intc_2 // 3
    <=
    bnz mint_eco_after_if_else@15
    // contract.py:138
    // cursor = UInt64(0)
    intc_0 // 0
    bury 7
    // contract.py:139
    // for i in urange(plot_count_as_string.length):
    intc_0 // 0
    bury 6

mint_eco_for_header@11:
    // contract.py:139
    // for i in urange(plot_count_as_string.length):
    dig 5
    dig 1
    <
    bz mint_eco_after_if_else@15
    // contract.py:140
    // cursor += 1
    dig 6
    intc_1 // 1
    +
    dup
    bury 8
    // contract.py:141
    // if cursor == 3:
    intc_2 // 3
    ==
    bz mint_eco_after_if_else@14
    // contract.py:142
    // plot_count_with_commas = plot_count_with_commas + b','
    dig 1
    pushbytes 0x2c
    concat
    bury 2
    // contract.py:143
    // cursor = UInt64(0)
    intc_0 // 0
    bury 7

mint_eco_after_if_else@14:
    // contract.py:144
    // plot_count_with_commas = plot_count_with_commas + plot_count_as_string[i]
    dig 2
    dig 6
    dup
    cover 2
    intc_1 // 1
    extract3
    dig 3
    swap
    concat
    bury 3
    // contract.py:139
    // for i in urange(plot_count_as_string.length):
    intc_1 // 1
    +
    bury 6
    b mint_eco_for_header@11

mint_eco_after_if_else@15:
    // contract.py:146-154
    // create_initial_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + itoa(self.plot_count),
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:147
    // asset_name=b'Plot #: ' + itoa(self.plot_count),
    intc_0 // 0
    bytec_0 // "plot_count"
    app_global_get_ex
    assert // check self.plot_count exists
    callsub itoa
    bytec 11 // 0x506c6f7420233a20
    swap
    concat
    // contract.py:151
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:152
    // reserve=Global.current_application_address,
    dup
    // contract.py:153
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:150
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:149
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // contract.py:148
    // unit_name='PLOT',
    bytec 12 // "PLOT"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // contract.py:146
    // create_initial_plot = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:146-154
    // create_initial_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + itoa(self.plot_count),
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    // contract.py:82
    // self.next_plot = self.mint_initial_plot()
    bytec_1 // "next_plot"
    itxn CreatedAssetID
    app_global_put
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:84
    // post_mbr = get_mbr() + 2_000_000 # Add 2 Algo for the bootstrap fee & initial liquidity add fee
    pushint 2000000 // 2000000
    +
    // contract.py:85
    // refund_excess_mbr(pre_mbr, post_mbr, mbr_payment)
    dig 4
    swap
    dig 6
    callsub refund_excess_mbr
    // contract.py:58
    // @abimethod
    intc_1 // 1
    return


// contract.Eco.mint_plot[routing]() -> void:
mint_plot:
    intc_0 // 0
    dup
    bytec_2 // ""
    dupn 2
    // contract.py:159
    // @abimethod
    txn GroupIndex
    pushint 2 // 2
    -
    txn GroupIndex
    intc_1 // 1
    -
    dup
    cover 2
    // contract.py:161
    // contract_is_receiver(plot_payment)
    dig 1
    callsub contract_is_receiver
    // contract.py:162
    // contract_is_receiver(mbr_payment)
    dup
    callsub contract_is_receiver
    // contract.py:22
    // assert txn.type == TransactionType.Payment
    dig 1
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert
    // contract.py:210
    // assert txn.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contract.py:211
    // assert txn.amount == self.plot_cost
    gtxns Amount
    intc_0 // 0
    bytec 5 // "plot_cost"
    app_global_get_ex
    assert // check self.plot_cost exists
    ==
    assert
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:215
    // box = Box(Bytes, key=b'p' + Txn.sender.bytes) # p prefix for plots
    pushbytes 0x70
    txn Sender
    concat
    dup
    // contract.py:216
    // plot_info = PlotInfo(plot_id=arc4.UInt64(self.next_plot), plot_last_claim_time=arc4.UInt64(0))
    intc_0 // 0
    bytec_1 // "next_plot"
    app_global_get_ex
    assert // check self.next_plot exists
    itob
    bytec 10 // 0x0000000000000000
    concat
    swap
    // contract.py:217
    // if box:
    box_len
    bury 1
    bz mint_plot_else_body@15
    // contract.py:218
    // initial_box_length = box.length
    dig 1
    dup
    box_len
    assert // check Box exists
    // contract.py:219
    // box.resize(initial_box_length + 16)
    dup
    pushint 16 // 16
    +
    dig 2
    swap
    box_resize
    // contract.py:220
    // box.splice(initial_box_length, 16, plot_info.bytes)
    pushint 16 // 16
    uncover 3
    box_splice

mint_plot_after_if_else@16:
    // contract.py:170
    // self.plot_count += 1
    intc_0 // 0
    bytec_0 // "plot_count"
    app_global_get_ex
    assert // check self.plot_count exists
    intc_1 // 1
    +
    bytec_0 // "plot_count"
    dig 1
    app_global_put
    // contract.py:172
    // plot_count_as_string = itoa(self.plot_count)
    callsub itoa
    dup
    bury 9
    // contract.py:173
    // plot_count_with_commas = Bytes(b'')
    bytec_2 // 0x
    bury 8
    // contract.py:175
    // if plot_count_as_string.length <= 3:
    len
    dup
    bury 5
    intc_2 // 3
    <=
    bz mint_plot_else_body@3
    dig 7
    bury 7

mint_plot_after_if_else@10:
    // contract.py:186-194
    // create_next_users_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_begin
    // contract.py:187
    // asset_name=b'Plot #: ' + plot_count_with_commas,
    bytec 11 // 0x506c6f7420233a20
    dig 7
    concat
    // contract.py:191
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:192
    // reserve=Global.current_application_address,
    dup
    // contract.py:193
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // contract.py:190
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contract.py:189
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // contract.py:188
    // unit_name='PLOT',
    bytec 12 // "PLOT"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // contract.py:186
    // create_next_users_plot = itxn.AssetConfig(
    intc_2 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:186-194
    // create_next_users_plot = itxn.AssetConfig(
    //     asset_name=b'Plot #: ' + plot_count_with_commas,
    //     unit_name='PLOT',
    //     total=1,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     default_frozen=False,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // contract.py:196
    // self.next_plot = create_next_users_plot.created_asset.id
    bytec_1 // "next_plot"
    dig 1
    app_global_put
    // contract.py:198-202
    // itxn.AssetTransfer(
    //     asset_amount=1,
    //     asset_receiver=Txn.sender,
    //     xfer_asset=self.next_plot,
    // ).submit()
    itxn_begin
    // contract.py:200
    // asset_receiver=Txn.sender,
    txn Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract.py:199
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    // contract.py:198
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:198-202
    // itxn.AssetTransfer(
    //     asset_amount=1,
    //     asset_receiver=Txn.sender,
    //     xfer_asset=self.next_plot,
    // ).submit()
    itxn_submit
    // contract.py:10
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:205
    // refund_excess_mbr(pre_mbr, post_mbr, mbr_payment)
    dig 2
    swap
    dig 4
    callsub refund_excess_mbr
    // contract.py:159
    // @abimethod
    intc_1 // 1
    return

mint_plot_else_body@3:
    // contract.py:178
    // cursor = UInt64(0)
    intc_0 // 0
    bury 6
    // contract.py:179
    // for i in urange(plot_count_as_string.length):
    intc_0 // 0
    bury 5

mint_plot_for_header@4:
    // contract.py:179
    // for i in urange(plot_count_as_string.length):
    dig 4
    dig 4
    <
    bz mint_plot_after_if_else@10
    // contract.py:180
    // cursor += 1
    dig 5
    intc_1 // 1
    +
    dup
    bury 7
    // contract.py:181
    // if cursor == 3:
    intc_2 // 3
    ==
    bz mint_plot_after_if_else@7
    // contract.py:182
    // plot_count_with_commas = plot_count_with_commas + b','
    dig 6
    pushbytes 0x2c
    concat
    bury 7
    // contract.py:183
    // cursor = UInt64(0)
    intc_0 // 0
    bury 6

mint_plot_after_if_else@7:
    // contract.py:184
    // plot_count_with_commas = plot_count_with_commas + plot_count_as_string[i]
    dig 7
    dig 5
    dup
    cover 2
    intc_1 // 1
    extract3
    dig 8
    swap
    concat
    bury 8
    // contract.py:179
    // for i in urange(plot_count_as_string.length):
    intc_1 // 1
    +
    bury 5
    b mint_plot_for_header@4

mint_plot_else_body@15:
    // contract.py:223
    // box.create(size=UInt64(16))
    dig 1
    dup
    pushint 16 // 16
    box_create
    pop
    // contract.py:224
    // box.replace(0, plot_info.bytes)
    intc_0 // 0
    uncover 2
    box_replace
    b mint_plot_after_if_else@16
