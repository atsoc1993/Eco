# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "txn", "name": "mbr_payment"}], "name": "mint_eco", "returns": {"type": "uint64"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "txn", "name": "mbr_payment"}], "name": "bootstrap_via_outer_and_add_initial_liquidity", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "txn", "name": "plot_payment"}, {"type": "txn", "name": "mbr_payment"}], "name": "mint_plot", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "claim_plot_rewards", "returns": {"type": "uint64"}, "events": [], "readonly": false, "recommendations": {}}], "name": "Eco", "state": {"keys": {"box": {}, "global": {"eco_token": {"key": "ZWNvX3Rva2Vu", "keyType": "AVMString", "valueType": "AVMUint64"}, "eco_token_created": {"key": "ZWNvX3Rva2VuX2NyZWF0ZWQ=", "keyType": "AVMString", "valueType": "AVMUint64"}, "eco_lp_token": {"key": "ZWNvX2xwX3Rva2Vu", "keyType": "AVMString", "valueType": "AVMUint64"}, "plot_count": {"key": "cGxvdF9jb3VudA==", "keyType": "AVMString", "valueType": "AVMUint64"}, "next_plot": {"key": "bmV4dF9wbG90", "keyType": "AVMString", "valueType": "AVMUint64"}, "plot_cost": {"key": "cGxvdF9jb3N0", "keyType": "AVMString", "valueType": "AVMUint64"}, "plot_reward_rate": {"key": "cGxvdF9yZXdhcmRfcmF0ZQ==", "keyType": "AVMString", "valueType": "AVMUint64"}, "pool_logicsig_template": {"key": "cG9vbF9sb2dpY3NpZ190ZW1wbGF0ZQ==", "keyType": "AVMString", "valueType": "AVMBytes"}, "tinyman_router": {"key": "dGlueW1hbl9yb3V0ZXI=", "keyType": "AVMString", "valueType": "AVMUint64"}, "empty_plot_items": {"key": "ZW1wdHlfcGxvdF9pdGVtcw==", "keyType": "AVMString", "valueType": "byte[10]"}}, "local": {}}, "maps": {"box": {}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 2, "ints": 8}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CyAFAAEDBMCEPSYPCWVjb190b2tlbgluZXh0X3Bsb3QKcGxvdF9jb3VudAAMZWNvX2xwX3Rva2VuCXBsb3RfY29zdBBwbG90X3Jld2FyZF9yYXRlFnBvb2xfbG9naWNzaWdfdGVtcGxhdGUOdGlueW1hbl9yb3V0ZXIQZW1wdHlfcGxvdF9pdGVtcwowMTIzNDU2Nzg5A0VDTwQVH3x1CFBsb3QgIzogBFBMT1QxGEAAjCgiZ4ARZWNvX3Rva2VuX2NyZWF0ZWQiZycEImcqI2cpImcnBYGQTmcnBiEEZ4BAQm9BWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ1FCYk5RQTBBREVZRWtReEdZRUJFa1NCQVVNPV4BJwdMZycIgZig7kZnJwmACgAAAAAAAAAAAABnMRtBACsxGRREMRhEggQER+d8OARvmRH9BHE1EkEEfM6fHzYaAI4EAIcA4QJpA7MAMRkUMRgUEEQjQzEAMgkSRImKAQCL/zgQSSMSSUAAB4sAJRJBABkjRIsBQQAJi/84BzIKEkSJi/84FDIKEkSJIkL/5IoDAIv+i/0Ji/84CEwJsTEAsgeyCCOyECKyAbOJigEBi/+BCgxBAAcnCov/I1iJi/+BCgqI/+aL/4EKGCcKTCNYUIkxFiMJiP99SYj/gEk4ECMSRDIKcwFEsTIKSSKyJLIqsikisiOB////////////AbIiJwuyJScLsiYkshAisgGzKLQ8ZzIKcwFETwKI/28iKGVEFicMTFCwI0MrSTEWIwlJiP8gSYj/IzgQIxJEMgpzAUQiJwdlREkVIksBDyJLAk8CTSRLAg8kSwNPAk1LA04CUiInCGVESRZPAkxQIihlREkWTwJMUIAIAAAAAAAAAABQgRtLBA+BG0sFTwJNTwVMTwVSUIAHUHJvZ3JhbUxQA0lLA4ATcG9vbF90b2tlbl9hc3NldF9pZGNIMgqxshRJshElshAisgG2gYCAgICAgICAgAGyEksBshRPArIRJbIQIrIBtiEEsghLAbIHI7IQIrIBtkyyHEmyMIAVYWRkX2luaXRpYWxfbGlxdWlkaXR5shoishlMshiBBrIQIrIBsycETGciKmVEiP59SStMFUkkDkEAQEsCRQKxJw1LAlAyCkcCI7IksiuyKrIpIrIjI7IiJw6yJbImJLIQIrIBsym0PGcyCnMBRCEECEsETEsGiP4YI0MiRQciRQZLBUsBDEH/tksGIwhJRQgkEkEAC0sBgAEsUEUCIkUHSwJLBklOAiNYSwNMUEUDIwhFBkL/yyJJK0cCMRaBAgkxFiMJSU4CSwGI/ZNJiP2PSwE4ECMSRDgQIxJESTgHMgoSRDgIIicFZUQSRDIKcwFEgAFwMQBQSSIpZUQWMgcWIicJZUROAlBMUE4CvUUBQQDiSb1ESYEaCEsCTNOBGksD0iIqZUQjCCpLAWeI/X9JRQkrRQgVSUUFJA5BAHtLB0UHsScNSwdQMgpHAiOyJLIrsiqyKSKyIyOyIicOsiWyJiSyECKyAbO0PCIpZUQxALEisi9LAbItsi6BBbIQIrIBs7ExAEsBshGyFCOyEiWyECKyAbMxALEjsi+yLrItgQWyECKyAbMpTGcyCnMBREsCTEsEiPzaI0MiRQYiRQVLBEsEDEH/e0sFIwhJRQckEkEAC0sGgAEsUEUHIkUGSwdLBUlOAiNYSwhMUEUIIwhFBUL/y0mBGrlIIksCu0L/IiKAAXAxAFBJvUSBGgoiSUsCDEEAOEcCgRoISwRJTgNLAk8CujIHTIEIWwkiJwZlRAtLBghFBkmBCAgyBxZPA08CgQhPA9IjCEUBQv/BsSIoZUQxALIUSwRJTgKyErIRJbIQIrIBsxYnDExQsCND", "clear": "C4EBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 5, "minor": 3, "patch": 2}}, "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMyA0IDEwMDAwMDAKICAgIGJ5dGVjYmxvY2sgImVjb190b2tlbiIgIm5leHRfcGxvdCIgInBsb3RfY291bnQiIDB4ICJlY29fbHBfdG9rZW4iICJwbG90X2Nvc3QiICJwbG90X3Jld2FyZF9yYXRlIiAicG9vbF9sb2dpY3NpZ190ZW1wbGF0ZSIgInRpbnltYW5fcm91dGVyIiAiZW1wdHlfcGxvdF9pdGVtcyIgMHgzMDMxMzIzMzM0MzUzNjM3MzgzOSAiRUNPIiAweDE1MWY3Yzc1IDB4NTA2YzZmNzQyMDIzM2EyMCAiUExPVCIKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIGNvbnRyYWN0LnB5OjUxCiAgICAvLyBzZWxmLmVjb190b2tlbiA9IFVJbnQ2NCgwKQogICAgYnl0ZWNfMCAvLyAiZWNvX3Rva2VuIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdC5weTo1MgogICAgLy8gc2VsZi5lY29fdG9rZW5fY3JlYXRlZCA9IEZhbHNlCiAgICBwdXNoYnl0ZXMgImVjb190b2tlbl9jcmVhdGVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdC5weTo1MwogICAgLy8gc2VsZi5lY29fbHBfdG9rZW4gPSBVSW50NjQoMCkKICAgIGJ5dGVjIDQgLy8gImVjb19scF90b2tlbiIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6NTQKICAgIC8vIHNlbGYucGxvdF9jb3VudCA9IFVJbnQ2NCgxKQogICAgYnl0ZWNfMiAvLyAicGxvdF9jb3VudCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6NTUKICAgIC8vIHNlbGYubmV4dF9wbG90ID0gVUludDY0KDApCiAgICBieXRlY18xIC8vICJuZXh0X3Bsb3QiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0LnB5OjU2CiAgICAvLyBzZWxmLnBsb3RfY29zdCA9IFVJbnQ2NCgxMF8wMDApCiAgICBieXRlYyA1IC8vICJwbG90X2Nvc3QiCiAgICBwdXNoaW50IDEwMDAwIC8vIDEwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6NTcKICAgIC8vIHNlbGYucGxvdF9yZXdhcmRfcmF0ZSA9IFVJbnQ2NCgxXzAwMF8wMDApCiAgICBieXRlYyA2IC8vICJwbG90X3Jld2FyZF9yYXRlIgogICAgaW50YyA0IC8vIDEwMDAwMDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdC5weTo1OAogICAgLy8gc2VsZi5wb29sX2xvZ2ljc2lnX3RlbXBsYXRlID0gb3AuYmFzZTY0X2RlY29kZShvcC5CYXNlNjQuU3RkRW5jb2RpbmcsIGIiQm9BWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ1FCYk5RQTBBREVZRWtReEdZRUJFa1NCQVVNPSIpCiAgICBwdXNoYnl0ZXMgMHg0MjZmNDE1OTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE0MTQxNDE2NzUxNDI2MjRlNTE0MTMwNDE0NDQ1NTk0NTZiNTE3ODQ3NTk0NTQyNDU2YjUzNDI0MTU1NGQzZAogICAgYmFzZTY0X2RlY29kZSBTdGRFbmNvZGluZwogICAgYnl0ZWMgNyAvLyAicG9vbF9sb2dpY3NpZ190ZW1wbGF0ZSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdC5weTo1OQogICAgLy8gc2VsZi50aW55bWFuX3JvdXRlciA9IEFwcGxpY2F0aW9uKDE0ODYwNzAwMCkgI3Rlc3RuZXQKICAgIGJ5dGVjIDggLy8gInRpbnltYW5fcm91dGVyIgogICAgcHVzaGludCAxNDg2MDcwMDAgLy8gMTQ4NjA3MDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6NjAKICAgIC8vIHNlbGYuZW1wdHlfcGxvdF9pdGVtczogU3RhdGljQXJyYXlbQnl0ZSwgdC5MaXRlcmFsWzEwXV0gPSBTdGF0aWNBcnJheShCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApLCBCeXRlKDApKQogICAgYnl0ZWMgOSAvLyAiZW1wdHlfcGxvdF9pdGVtcyIKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBjb250cmFjdC5weTo0OQogICAgLy8gY2xhc3MgRWNvKEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ29weV9kZWZhdWx0X2NyZWF0ZUAxMwogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQKICAgIHB1c2hieXRlc3MgMHg0N2U3N2MzOCAweDZmOTkxMWZkIDB4NzEzNTEyNDEgMHg3Y2NlOWYxZiAvLyBtZXRob2QgIm1pbnRfZWNvKHR4bil1aW50NjQiLCBtZXRob2QgImJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eSh0eG4pdm9pZCIsIG1ldGhvZCAibWludF9wbG90KHR4bix0eG4pdm9pZCIsIG1ldGhvZCAiY2xhaW1fcGxvdF9yZXdhcmRzKCl1aW50NjQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtaW50X2VjbyBib290c3RyYXBfdmlhX291dGVyX2FuZF9hZGRfaW5pdGlhbF9saXF1aWRpdHkgbWludF9wbG90IGNsYWltX3Bsb3RfcmV3YXJkcwogICAgZXJyCgptYWluX19fYWxnb3B5X2RlZmF1bHRfY3JlYXRlQDEzOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdC5pc19jcmVhdG9yKCkgLT4gdm9pZDoKaXNfY3JlYXRvcjoKICAgIC8vIGNvbnRyYWN0LnB5OjcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgcmV0c3ViCgoKLy8gY29udHJhY3QuY29udHJhY3RfaXNfcmVjZWl2ZXIodHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNvbnRyYWN0X2lzX3JlY2VpdmVyOgogICAgLy8gY29udHJhY3QucHk6MTMtMTQKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgY29udHJhY3RfaXNfcmVjZWl2ZXIodHhuOiBndHhuLlRyYW5zYWN0aW9uKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBjb250cmFjdC5weToxNQogICAgLy8gYXNzZXJ0IHR4bi50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuUGF5bWVudCwgVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBkdXAKICAgIGJueiBjb250cmFjdF9pc19yZWNlaXZlcl9ib29sX3RydWVAMgogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMyAvLyBheGZlcgogICAgPT0KICAgIGJ6IGNvbnRyYWN0X2lzX3JlY2VpdmVyX2Jvb2xfZmFsc2VAMwoKY29udHJhY3RfaXNfcmVjZWl2ZXJfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKY29udHJhY3RfaXNfcmVjZWl2ZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gY29udHJhY3QucHk6MTUKICAgIC8vIGFzc2VydCB0eG4udHlwZSBpbiAoVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQsIFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyKQogICAgYXNzZXJ0CiAgICAvLyBjb250cmFjdC5weToxNgogICAgLy8gaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgMQogICAgYnogY29udHJhY3RfaXNfcmVjZWl2ZXJfZWxzZV9ib2R5QDYKICAgIC8vIGNvbnRyYWN0LnB5OjE3CiAgICAvLyBhc3NlcnQgdHhuLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0CiAgICByZXRzdWIKCmNvbnRyYWN0X2lzX3JlY2VpdmVyX2Vsc2VfYm9keUA2OgogICAgLy8gY29udHJhY3QucHk6MTkKICAgIC8vIGFzc2VydCB0eG4uYXNzZXRfcmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgcmV0c3ViCgpjb250cmFjdF9pc19yZWNlaXZlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBjb250cmFjdF9pc19yZWNlaXZlcl9ib29sX21lcmdlQDQKCgovLyBjb250cmFjdC5yZWZ1bmRfZXhjZXNzX21icihwcmVfbWJyOiB1aW50NjQsIHBvc3RfbWJyOiB1aW50NjQsIG1icl9wYXltZW50OiB1aW50NjQpIC0+IHZvaWQ6CnJlZnVuZF9leGNlc3NfbWJyOgogICAgLy8gY29udHJhY3QucHk6MjUtMjYKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgcmVmdW5kX2V4Y2Vzc19tYnIocHJlX21icjogVUludDY0LCBwb3N0X21icjogVUludDY0LCBtYnJfcGF5bWVudDogZ3R4bi5UcmFuc2FjdGlvbikgLT4gTm9uZToKICAgIHByb3RvIDMgMAogICAgLy8gY29udHJhY3QucHk6MjcKICAgIC8vIG1icl91c2VkID0gcG9zdF9tYnIgLSBwcmVfbWJyCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMwogICAgLQogICAgLy8gY29udHJhY3QucHk6MjgKICAgIC8vIGV4Y2VzcyA9IG1icl9wYXltZW50LmFtb3VudCAtIG1icl91c2VkCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgc3dhcAogICAgLQogICAgLy8gY29udHJhY3QucHk6MjktMzIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudD1leGNlc3MKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGNvbnRyYWN0LnB5OjMwCiAgICAvLyByZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIGNvbnRyYWN0LnB5OjI5CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGNvbnRyYWN0LnB5OjI5LTMyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ9ZXhjZXNzCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gY29udHJhY3QuaXRvYShpOiB1aW50NjQpIC0+IGJ5dGVzOgppdG9hOgogICAgLy8gY29udHJhY3QucHk6MzQtMzUKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgaXRvYShpOiBVSW50NjQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMSAxCiAgICAvLyBjb250cmFjdC5weTozOAogICAgLy8gaWYgaSA8IHJhZGl4OgogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBjb250cmFjdC5weTozNwogICAgLy8gcmFkaXggPSBkaWdpdHMubGVuZ3RoCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICAvLyBjb250cmFjdC5weTozOAogICAgLy8gaWYgaSA8IHJhZGl4OgogICAgPAogICAgYnogaXRvYV9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIGNvbnRyYWN0LnB5OjM2CiAgICAvLyBkaWdpdHMgPSBCeXRlcyhiIjAxMjM0NTY3ODkiKQogICAgYnl0ZWMgMTAgLy8gMHgzMDMxMzIzMzM0MzUzNjM3MzgzOQogICAgLy8gY29udHJhY3QucHk6MzkKICAgIC8vIHJldHVybiBkaWdpdHNbaV0KICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3QzCiAgICByZXRzdWIKCml0b2FfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gY29udHJhY3QucHk6NDEKICAgIC8vIHJldHVybiBpdG9hKGkgLy8gcmFkaXgpICsgZGlnaXRzW2kgJSByYWRpeF0KICAgIGZyYW1lX2RpZyAtMQogICAgLy8gY29udHJhY3QucHk6MzcKICAgIC8vIHJhZGl4ID0gZGlnaXRzLmxlbmd0aAogICAgcHVzaGludCAxMCAvLyAxMAogICAgLy8gY29udHJhY3QucHk6NDEKICAgIC8vIHJldHVybiBpdG9hKGkgLy8gcmFkaXgpICsgZGlnaXRzW2kgJSByYWRpeF0KICAgIC8KICAgIGNhbGxzdWIgaXRvYQogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBjb250cmFjdC5weTozNwogICAgLy8gcmFkaXggPSBkaWdpdHMubGVuZ3RoCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICAvLyBjb250cmFjdC5weTo0MQogICAgLy8gcmV0dXJuIGl0b2EoaSAvLyByYWRpeCkgKyBkaWdpdHNbaSAlIHJhZGl4XQogICAgJQogICAgLy8gY29udHJhY3QucHk6MzYKICAgIC8vIGRpZ2l0cyA9IEJ5dGVzKGIiMDEyMzQ1Njc4OSIpCiAgICBieXRlYyAxMCAvLyAweDMwMzEzMjMzMzQzNTM2MzczODM5CiAgICAvLyBjb250cmFjdC5weTo0MQogICAgLy8gcmV0dXJuIGl0b2EoaSAvLyByYWRpeCkgKyBkaWdpdHNbaSAlIHJhZGl4XQogICAgc3dhcAogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3QzCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0LkVjby5taW50X2Vjb1tyb3V0aW5nXSgpIC0+IHZvaWQ6Cm1pbnRfZWNvOgogICAgLy8gY29udHJhY3QucHk6NjIKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgLy8gY29udHJhY3QucHk6NjQKICAgIC8vIGlzX2NyZWF0b3IoKQogICAgY2FsbHN1YiBpc19jcmVhdG9yCiAgICAvLyBjb250cmFjdC5weTo2NQogICAgLy8gY29udHJhY3RfaXNfcmVjZWl2ZXIobWJyX3BheW1lbnQpCiAgICBkdXAKICAgIGNhbGxzdWIgY29udHJhY3RfaXNfcmVjZWl2ZXIKICAgIC8vIGNvbnRyYWN0LnB5OjIzCiAgICAvLyBhc3NlcnQgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQKICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0LnB5OjExCiAgICAvLyByZXR1cm4gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBjb250cmFjdC5weTo2OS03NwogICAgLy8gY3JlYXRlX2Vjb190eG4gPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgLy8gICAgIGFzc2V0X25hbWU9J0VDTycsCiAgICAvLyAgICAgdW5pdF9uYW1lPSdFQ08nLAogICAgLy8gICAgIHRvdGFsPVVJbnQ2NCgoMioqNjQpIC0gMSksCiAgICAvLyAgICAgZGVjaW1hbHM9MCwKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gY29udHJhY3QucHk6NzQKICAgIC8vIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBjb250cmFjdC5weTo3NQogICAgLy8gcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZHVwCiAgICAvLyBjb250cmFjdC5weTo3NgogICAgLy8gZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlZmF1bHRGcm96ZW4KICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgogICAgLy8gY29udHJhY3QucHk6NzMKICAgIC8vIGRlY2ltYWxzPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlY2ltYWxzCiAgICAvLyBjb250cmFjdC5weTo3MgogICAgLy8gdG90YWw9VUludDY0KCgyKio2NCkgLSAxKSwKICAgIHB1c2hpbnQgMTg0NDY3NDQwNzM3MDk1NTE2MTUgLy8gMTg0NDY3NDQwNzM3MDk1NTE2MTUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRUb3RhbAogICAgLy8gY29udHJhY3QucHk6NzEKICAgIC8vIHVuaXRfbmFtZT0nRUNPJywKICAgIGJ5dGVjIDExIC8vICJFQ08iCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKICAgIC8vIGNvbnRyYWN0LnB5OjcwCiAgICAvLyBhc3NldF9uYW1lPSdFQ08nLAogICAgYnl0ZWMgMTEgLy8gIkVDTyIKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICAvLyBjb250cmFjdC5weTo2OQogICAgLy8gY3JlYXRlX2Vjb190eG4gPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgaW50Y18yIC8vIGFjZmcKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gY29udHJhY3QucHk6NjktNzcKICAgIC8vIGNyZWF0ZV9lY29fdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICBhc3NldF9uYW1lPSdFQ08nLAogICAgLy8gICAgIHVuaXRfbmFtZT0nRUNPJywKICAgIC8vICAgICB0b3RhbD1VSW50NjQoKDIqKjY0KSAtIDEpLAogICAgLy8gICAgIGRlY2ltYWxzPTAsCiAgICAvLyAgICAgbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlc2VydmU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1GYWxzZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBjb250cmFjdC5weTo4MAogICAgLy8gc2VsZi5lY29fdG9rZW4gPSBjcmVhdGVfZWNvX3R4bi5jcmVhdGVkX2Fzc2V0LmlkCiAgICBieXRlY18wIC8vICJlY29fdG9rZW4iCiAgICBpdHhuIENyZWF0ZWRBc3NldElECiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6MTEKICAgIC8vIHJldHVybiBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIGNvbnRyYWN0LnB5Ojg5CiAgICAvLyByZWZ1bmRfZXhjZXNzX21icihwcmVfbWJyLCBwb3N0X21iciwgbWJyX3BheW1lbnQpCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgcmVmdW5kX2V4Y2Vzc19tYnIKICAgIC8vIGNvbnRyYWN0LnB5OjkwCiAgICAvLyByZXR1cm4gc2VsZi5lY29fdG9rZW4KICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlY29fdG9rZW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZWNvX3Rva2VuIGV4aXN0cwogICAgLy8gY29udHJhY3QucHk6NjIKICAgIC8vIEBhYmltZXRob2QKICAgIGl0b2IKICAgIGJ5dGVjIDEyIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3QuRWNvLmJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eToKICAgIGJ5dGVjXzMgLy8gIiIKICAgIGR1cAogICAgLy8gY29udHJhY3QucHk6OTUKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICAvLyBjb250cmFjdC5weToxMDIKICAgIC8vIGlzX2NyZWF0b3IoKQogICAgY2FsbHN1YiBpc19jcmVhdG9yCiAgICAvLyBjb250cmFjdC5weToxMDMKICAgIC8vIGNvbnRyYWN0X2lzX3JlY2VpdmVyKG1icl9wYXltZW50KQogICAgZHVwCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBjb250cmFjdC5weToyMwogICAgLy8gYXNzZXJ0IHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5QYXltZW50CiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydAogICAgLy8gY29udHJhY3QucHk6MTEKICAgIC8vIHJldHVybiBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIGNvbnRyYWN0LnB5OjI5MQogICAgLy8gcHJvZ3JhbV9ieXRlcyA9IHNlbGYucG9vbF9sb2dpY3NpZ190ZW1wbGF0ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gInBvb2xfbG9naWNzaWdfdGVtcGxhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucG9vbF9sb2dpY3NpZ190ZW1wbGF0ZSBleGlzdHMKICAgIC8vIGNvbnRyYWN0LnB5OjI5NAogICAgLy8gcHJvZ3JhbV9ieXRlc1swOjNdICsKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDEKICAgID49CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBpbnRjXzIgLy8gMwogICAgZGlnIDIKICAgID49CiAgICBpbnRjXzIgLy8gMwogICAgZGlnIDMKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBkaWcgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gY29udHJhY3QucHk6Mjk1CiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnRpbnltYW5fcm91dGVyLmlkKS5ieXRlcyArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAidGlueW1hbl9yb3V0ZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGlueW1hbl9yb3V0ZXIgZXhpc3RzCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0LnB5OjI5NC0yOTUKICAgIC8vIHByb2dyYW1fYnl0ZXNbMDozXSArCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnRpbnltYW5fcm91dGVyLmlkKS5ieXRlcyArCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3QucHk6Mjk2CiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLmVjb190b2tlbikuYnl0ZXMgKwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVjb190b2tlbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5lY29fdG9rZW4gZXhpc3RzCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0LnB5OjI5NC0yOTYKICAgIC8vIHByb2dyYW1fYnl0ZXNbMDozXSArCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnRpbnltYW5fcm91dGVyLmlkKS5ieXRlcyArCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLmVjb190b2tlbikuYnl0ZXMgKwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0LnB5OjI5NwogICAgLy8gYXJjNC5VSW50NjQoMCkuYnl0ZXMgKwogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgLy8gY29udHJhY3QucHk6Mjk0LTI5NwogICAgLy8gcHJvZ3JhbV9ieXRlc1swOjNdICsKICAgIC8vIGFyYzQuVUludDY0KHNlbGYudGlueW1hbl9yb3V0ZXIuaWQpLmJ5dGVzICsKICAgIC8vIGFyYzQuVUludDY0KHNlbGYuZWNvX3Rva2VuKS5ieXRlcyArCiAgICAvLyBhcmM0LlVJbnQ2NCgwKS5ieXRlcyArCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0LnB5OjI5OAogICAgLy8gcHJvZ3JhbV9ieXRlc1syNzpdCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBkaWcgNAogICAgPj0KICAgIHB1c2hpbnQgMjcgLy8gMjcKICAgIGRpZyA1CiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgdW5jb3ZlciA1CiAgICBzd2FwCiAgICB1bmNvdmVyIDUKICAgIHN1YnN0cmluZzMKICAgIC8vIGNvbnRyYWN0LnB5OjI5NC0yOTgKICAgIC8vIHByb2dyYW1fYnl0ZXNbMDozXSArCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLnRpbnltYW5fcm91dGVyLmlkKS5ieXRlcyArCiAgICAvLyBhcmM0LlVJbnQ2NChzZWxmLmVjb190b2tlbikuYnl0ZXMgKwogICAgLy8gYXJjNC5VSW50NjQoMCkuYnl0ZXMgKwogICAgLy8gcHJvZ3JhbV9ieXRlc1syNzpdCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0LnB5OjMwMQogICAgLy8gcmV0dXJuIEFjY291bnQuZnJvbV9ieXRlcyhvcC5zaGE1MTJfMjU2KGInUHJvZ3JhbScgKyBwcm9ncmFtX2J5dGVzKSkKICAgIHB1c2hieXRlcyAweDUwNzI2ZjY3NzI2MTZkCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHNoYTUxMl8yNTYKICAgIC8vIGNvbnRyYWN0LnB5OjE2NgogICAgLy8gTFBfdG9rZW5faWQgPSBBc3NldChvcC5BcHBMb2NhbC5nZXRfZXhfdWludDY0KHBvb2xfYWRkcmVzcywgc2VsZi50aW55bWFuX3JvdXRlciwgYidwb29sX3Rva2VuX2Fzc2V0X2lkJylbMF0pCiAgICBkdXAKICAgIGRpZyAzCiAgICBwdXNoYnl0ZXMgMHg3MDZmNmY2YzVmNzQ2ZjZiNjU2ZTVmNjE3MzczNjU3NDVmNjk2NAogICAgYXBwX2xvY2FsX2dldF9leAogICAgcG9wCiAgICAvLyBjb250cmFjdC5weToxNTAKICAgIC8vIG9wdGluX2xwID0gaXR4bi5Bc3NldFRyYW5zZmVyKHhmZXJfYXNzZXQ9TFBfdG9rZW4sIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gY29udHJhY3QucHk6MTYxCiAgICAvLyBpdHhuLnN1Ym1pdF90eG5zKG9wdGluX2xwLCB0cmFuc2Zlcl9hc3NldCwgdHJhbnNmZXJfYWxnbywgYWRkX2xwX2NhbGwpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGR1cAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGNvbnRyYWN0LnB5OjE1MAogICAgLy8gb3B0aW5fbHAgPSBpdHhuLkFzc2V0VHJhbnNmZXIoeGZlcl9hc3NldD1MUF90b2tlbiwgYXNzZXRfcmVjZWl2ZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcykKICAgIGludGNfMyAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToxNjEKICAgIC8vIGl0eG4uc3VibWl0X3R4bnMob3B0aW5fbHAsIHRyYW5zZmVyX2Fzc2V0LCB0cmFuc2Zlcl9hbGdvLCBhZGRfbHBfY2FsbCkKICAgIGl0eG5fbmV4dAogICAgLy8gY29udHJhY3QucHk6MTUxCiAgICAvLyB0cmFuc2Zlcl9hc3NldCA9IGl0eG4uQXNzZXRUcmFuc2Zlcih4ZmVyX2Fzc2V0PXNlbGYuZWNvX3Rva2VuLCBhc3NldF9yZWNlaXZlcj1wb29sX2FkZHJlc3MsIGFzc2V0X2Ftb3VudD0yKio2NCAvLyAyKQogICAgcHVzaGludCA5MjIzMzcyMDM2ODU0Nzc1ODA4IC8vIDkyMjMzNzIwMzY4NTQ3NzU4MDgKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGludGNfMyAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToxNjEKICAgIC8vIGl0eG4uc3VibWl0X3R4bnMob3B0aW5fbHAsIHRyYW5zZmVyX2Fzc2V0LCB0cmFuc2Zlcl9hbGdvLCBhZGRfbHBfY2FsbCkKICAgIGl0eG5fbmV4dAogICAgLy8gY29udHJhY3QucHk6MTUyCiAgICAvLyB0cmFuc2Zlcl9hbGdvID0gaXR4bi5QYXltZW50KHJlY2VpdmVyPXBvb2xfYWRkcmVzcywgYW1vdW50PTFfMDAwXzAwMCkKICAgIGludGMgNCAvLyAxMDAwMDAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gY29udHJhY3QucHk6MTYxCiAgICAvLyBpdHhuLnN1Ym1pdF90eG5zKG9wdGluX2xwLCB0cmFuc2Zlcl9hc3NldCwgdHJhbnNmZXJfYWxnbywgYWRkX2xwX2NhbGwpCiAgICBpdHhuX25leHQKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQWNjb3VudHMKICAgIGR1cAogICAgaXR4bl9maWVsZCBBc3NldHMKICAgIC8vIGNvbnRyYWN0LnB5OjE1MwogICAgLy8gdGlueV9hcmdzID0gQnl0ZXMoYidhZGRfaW5pdGlhbF9saXF1aWRpdHknKQogICAgcHVzaGJ5dGVzIDB4NjE2NDY0NWY2OTZlNjk3NDY5NjE2YzVmNmM2OTcxNzU2OTY0Njk3NDc5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gY29udHJhY3QucHk6MTU2CiAgICAvLyBvbl9jb21wbGV0aW9uPU9uQ29tcGxldGVBY3Rpb24uTm9PcCwKICAgIGludGNfMCAvLyBOb09wCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBjb250cmFjdC5weToxNTQKICAgIC8vIGFkZF9scF9jYWxsID0gaXR4bi5BcHBsaWNhdGlvbkNhbGwoCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToxNjEKICAgIC8vIGl0eG4uc3VibWl0X3R4bnMob3B0aW5fbHAsIHRyYW5zZmVyX2Fzc2V0LCB0cmFuc2Zlcl9hbGdvLCBhZGRfbHBfY2FsbCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBjb250cmFjdC5weToxMDktMTEwCiAgICAvLyAjIHNlbGYuaXNfYm9vdHN0cmFwcGluZyhwb29sX2FkZHJlc3MsIGJvb3RzdHJhcF9mZWUsIGJvb3RzdHJhcF90eCkKICAgIC8vIHNlbGYuZWNvX2xwX3Rva2VuID0gc2VsZi5hZGRfaW5pdGlhbF9saXF1aWRpdHkocG9vbF9hZGRyZXNzKQogICAgYnl0ZWMgNCAvLyAiZWNvX2xwX3Rva2VuIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0LnB5OjE3MQogICAgLy8gcGxvdF9jb3VudF9hc19zdHJpbmcgPSBpdG9hKHNlbGYucGxvdF9jb3VudCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJwbG90X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsb3RfY291bnQgZXhpc3RzCiAgICBjYWxsc3ViIGl0b2EKICAgIGR1cAogICAgLy8gY29udHJhY3QucHk6MTcyCiAgICAvLyBwbG90X2NvdW50X3dpdGhfY29tbWFzID0gQnl0ZXMoYicnKQogICAgYnl0ZWNfMyAvLyAweAogICAgc3dhcAogICAgLy8gY29udHJhY3QucHk6MTc0CiAgICAvLyBpZiBwbG90X2NvdW50X2FzX3N0cmluZy5sZW5ndGggPD0gMzoKICAgIGxlbgogICAgZHVwCiAgICBpbnRjXzIgLy8gMwogICAgPD0KICAgIGJ6IGJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eV9lbHNlX2JvZHlANwogICAgZGlnIDIKICAgIGJ1cnkgMgoKYm9vdHN0cmFwX3ZpYV9vdXRlcl9hbmRfYWRkX2luaXRpYWxfbGlxdWlkaXR5X2FmdGVyX2lmX2Vsc2VAMTM6CiAgICAvLyBjb250cmFjdC5weToxODUtMTk0CiAgICAvLyBjcmVhdGVfaW5pdGlhbF9wbG90ID0gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICBhc3NldF9uYW1lPWInUGxvdCAjOiAnICsgcGxvdF9jb3VudF93aXRoX2NvbW1hcywKICAgIC8vICAgICB1bml0X25hbWU9J1BMT1QnLAogICAgLy8gICAgIHRvdGFsPTEsCiAgICAvLyAgICAgZGVjaW1hbHM9MCwKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPVRydWUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBjb250cmFjdC5weToxODYKICAgIC8vIGFzc2V0X25hbWU9YidQbG90ICM6ICcgKyBwbG90X2NvdW50X3dpdGhfY29tbWFzLAogICAgYnl0ZWMgMTMgLy8gMHg1MDZjNmY3NDIwMjMzYTIwCiAgICBkaWcgMgogICAgY29uY2F0CiAgICAvLyBjb250cmFjdC5weToxOTAKICAgIC8vIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBjb250cmFjdC5weToxOTEtMTkyCiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGR1cG4gMgogICAgLy8gY29udHJhY3QucHk6MTkzCiAgICAvLyBkZWZhdWx0X2Zyb3plbj1UcnVlLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RnJlZXplCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE1hbmFnZXIKICAgIC8vIGNvbnRyYWN0LnB5OjE4OQogICAgLy8gZGVjaW1hbHM9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIC8vIGNvbnRyYWN0LnB5OjE4OAogICAgLy8gdG90YWw9MSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKICAgIC8vIGNvbnRyYWN0LnB5OjE4NwogICAgLy8gdW5pdF9uYW1lPSdQTE9UJywKICAgIGJ5dGVjIDE0IC8vICJQTE9UIgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVuaXROYW1lCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TmFtZQogICAgLy8gY29udHJhY3QucHk6MTg1CiAgICAvLyBjcmVhdGVfaW5pdGlhbF9wbG90ID0gaXR4bi5Bc3NldENvbmZpZygKICAgIGludGNfMiAvLyBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGNvbnRyYWN0LnB5OjE4NS0xOTQKICAgIC8vIGNyZWF0ZV9pbml0aWFsX3Bsb3QgPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgLy8gICAgIGFzc2V0X25hbWU9YidQbG90ICM6ICcgKyBwbG90X2NvdW50X3dpdGhfY29tbWFzLAogICAgLy8gICAgIHVuaXRfbmFtZT0nUExPVCcsCiAgICAvLyAgICAgdG90YWw9MSwKICAgIC8vICAgICBkZWNpbWFscz0wLAogICAgLy8gICAgIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZnJlZXplPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZGVmYXVsdF9mcm96ZW49VHJ1ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBjb250cmFjdC5weToxMTIKICAgIC8vIHNlbGYubmV4dF9wbG90ID0gc2VsZi5taW50X2luaXRpYWxfcGxvdCgpCiAgICBieXRlY18xIC8vICJuZXh0X3Bsb3QiCiAgICBpdHhuIENyZWF0ZWRBc3NldElECiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6MTEKICAgIC8vIHJldHVybiBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIGNvbnRyYWN0LnB5OjExNAogICAgLy8gcG9zdF9tYnIgPSBnZXRfbWJyKCkgKyAxXzAwMF8wMDAgIyBBZGQgMSBBbGdvIGZvciB0aGUgaW5pdGlhbCBsaXF1aWRpdHkgYWRkIGZlZQogICAgaW50YyA0IC8vIDEwMDAwMDAKICAgICsKICAgIC8vIGNvbnRyYWN0LnB5OjExNQogICAgLy8gcmVmdW5kX2V4Y2Vzc19tYnIocHJlX21iciwgcG9zdF9tYnIsIG1icl9wYXltZW50KQogICAgZGlnIDQKICAgIHN3YXAKICAgIGRpZyA2CiAgICBjYWxsc3ViIHJlZnVuZF9leGNlc3NfbWJyCiAgICAvLyBjb250cmFjdC5weTo5NQogICAgLy8gQGFiaW1ldGhvZAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYm9vdHN0cmFwX3ZpYV9vdXRlcl9hbmRfYWRkX2luaXRpYWxfbGlxdWlkaXR5X2Vsc2VfYm9keUA3OgogICAgLy8gY29udHJhY3QucHk6MTc3CiAgICAvLyBjdXJzb3IgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDcKICAgIC8vIGNvbnRyYWN0LnB5OjE3OAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHBsb3RfY291bnRfYXNfc3RyaW5nLmxlbmd0aCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA2Cgpib290c3RyYXBfdmlhX291dGVyX2FuZF9hZGRfaW5pdGlhbF9saXF1aWRpdHlfZm9yX2hlYWRlckA4OgogICAgLy8gY29udHJhY3QucHk6MTc4CiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UocGxvdF9jb3VudF9hc19zdHJpbmcubGVuZ3RoKToKICAgIGRpZyA1CiAgICBkaWcgMQogICAgPAogICAgYnogYm9vdHN0cmFwX3ZpYV9vdXRlcl9hbmRfYWRkX2luaXRpYWxfbGlxdWlkaXR5X2FmdGVyX2lmX2Vsc2VAMTMKICAgIC8vIGNvbnRyYWN0LnB5OjE3OQogICAgLy8gY3Vyc29yICs9IDEKICAgIGRpZyA2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZHVwCiAgICBidXJ5IDgKICAgIC8vIGNvbnRyYWN0LnB5OjE4MAogICAgLy8gaWYgY3Vyc29yID09IDM6CiAgICBpbnRjXzIgLy8gMwogICAgPT0KICAgIGJ6IGJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eV9hZnRlcl9pZl9lbHNlQDExCiAgICAvLyBjb250cmFjdC5weToxODEKICAgIC8vIHBsb3RfY291bnRfd2l0aF9jb21tYXMgPSBwbG90X2NvdW50X3dpdGhfY29tbWFzICsgYicsJwogICAgZGlnIDEKICAgIHB1c2hieXRlcyAweDJjCiAgICBjb25jYXQKICAgIGJ1cnkgMgogICAgLy8gY29udHJhY3QucHk6MTgyCiAgICAvLyBjdXJzb3IgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDcKCmJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eV9hZnRlcl9pZl9lbHNlQDExOgogICAgLy8gY29udHJhY3QucHk6MTgzCiAgICAvLyBwbG90X2NvdW50X3dpdGhfY29tbWFzID0gcGxvdF9jb3VudF93aXRoX2NvbW1hcyArIHBsb3RfY291bnRfYXNfc3RyaW5nW2ldCiAgICBkaWcgMgogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3QzCiAgICBkaWcgMwogICAgc3dhcAogICAgY29uY2F0CiAgICBidXJ5IDMKICAgIC8vIGNvbnRyYWN0LnB5OjE3OAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHBsb3RfY291bnRfYXNfc3RyaW5nLmxlbmd0aCk6CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSA2CiAgICBiIGJvb3RzdHJhcF92aWFfb3V0ZXJfYW5kX2FkZF9pbml0aWFsX2xpcXVpZGl0eV9mb3JfaGVhZGVyQDgKCgovLyBjb250cmFjdC5FY28ubWludF9wbG90W3JvdXRpbmddKCkgLT4gdm9pZDoKbWludF9wbG90OgogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgYnl0ZWNfMyAvLyAiIgogICAgZHVwbiAyCiAgICAvLyBjb250cmFjdC5weToxOTgKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBHcm91cEluZGV4CiAgICBwdXNoaW50IDIgLy8gMgogICAgLQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIGNvbnRyYWN0LnB5OjIwMAogICAgLy8gY29udHJhY3RfaXNfcmVjZWl2ZXIocGxvdF9wYXltZW50KQogICAgZGlnIDEKICAgIGNhbGxzdWIgY29udHJhY3RfaXNfcmVjZWl2ZXIKICAgIC8vIGNvbnRyYWN0LnB5OjIwMQogICAgLy8gY29udHJhY3RfaXNfcmVjZWl2ZXIobWJyX3BheW1lbnQpCiAgICBkdXAKICAgIGNhbGxzdWIgY29udHJhY3RfaXNfcmVjZWl2ZXIKICAgIC8vIGNvbnRyYWN0LnB5OjIzCiAgICAvLyBhc3NlcnQgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQKICAgIGRpZyAxCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0LnB5OjI1MQogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBkdXAKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgLy8gY29udHJhY3QucHk6MjUyCiAgICAvLyBhc3NlcnQgdHhuLmFtb3VudCA9PSBzZWxmLnBsb3RfY29zdAogICAgZ3R4bnMgQW1vdW50CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicGxvdF9jb3N0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsb3RfY29zdCBleGlzdHMKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0LnB5OjExCiAgICAvLyByZXR1cm4gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBjb250cmFjdC5weToyNTYKICAgIC8vIHVzZXJzX3Bsb3RzID0gQm94KEJ5dGVzLCBrZXk9YidwJyArIFR4bi5zZW5kZXIuYnl0ZXMpICMgcCBwcmVmaXggZm9yIHBsb3RzCiAgICBwdXNoYnl0ZXMgMHg3MAogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIGNvbnRyYWN0LnB5OjI1OAogICAgLy8gcGxvdF9pZD1hcmM0LlVJbnQ2NChzZWxmLm5leHRfcGxvdCksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAibmV4dF9wbG90IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5leHRfcGxvdCBleGlzdHMKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0LnB5OjI1OQogICAgLy8gcGxvdF9sYXN0X2NsYWltX3RpbWU9YXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgLy8gY29udHJhY3QucHk6MjYwCiAgICAvLyBwbG90X2l0ZW1zPXNlbGYuZW1wdHlfcGxvdF9pdGVtcy5jb3B5KCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJlbXB0eV9wbG90X2l0ZW1zIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmVtcHR5X3Bsb3RfaXRlbXMgZXhpc3RzCiAgICAvLyBjb250cmFjdC5weToyNTctMjYxCiAgICAvLyBwbG90X2luZm8gPSBQbG90SW5mbygKICAgIC8vICAgICBwbG90X2lkPWFyYzQuVUludDY0KHNlbGYubmV4dF9wbG90KSwKICAgIC8vICAgICBwbG90X2xhc3RfY2xhaW1fdGltZT1hcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCksCiAgICAvLyAgICAgcGxvdF9pdGVtcz1zZWxmLmVtcHR5X3Bsb3RfaXRlbXMuY29weSgpCiAgICAvLyAgICAgKQogICAgY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGNvdmVyIDIKICAgIC8vIGNvbnRyYWN0LnB5OjI2MwogICAgLy8gaWYgdXNlcnNfcGxvdHM6CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IG1pbnRfcGxvdF9lbHNlX2JvZHlAMTkKICAgIC8vIGNvbnRyYWN0LnB5OjI2NAogICAgLy8gaW5pdGlhbF9ib3hfbGVuZ3RoID0gdXNlcnNfcGxvdHMubGVuZ3RoCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGFzc2VydCAvLyBjaGVjayBCb3ggZXhpc3RzCiAgICAvLyBjb250cmFjdC5weToyNjUKICAgIC8vIHVzZXJzX3Bsb3RzLnJlc2l6ZShpbml0aWFsX2JveF9sZW5ndGggKyAyNikKICAgIGR1cAogICAgcHVzaGludCAyNiAvLyAyNgogICAgKwogICAgZGlnIDIKICAgIHN3YXAKICAgIGJveF9yZXNpemUKICAgIC8vIGNvbnRyYWN0LnB5OjI2NgogICAgLy8gdXNlcnNfcGxvdHMuc3BsaWNlKGluaXRpYWxfYm94X2xlbmd0aCwgMjYsIHBsb3RfaW5mby5ieXRlcykKICAgIHB1c2hpbnQgMjYgLy8gMjYKICAgIGRpZyAzCiAgICBib3hfc3BsaWNlCgptaW50X3Bsb3RfYWZ0ZXJfaWZfZWxzZUAyMDoKICAgIC8vIGNvbnRyYWN0LnB5OjIwOQogICAgLy8gc2VsZi5wbG90X2NvdW50ICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJwbG90X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnBsb3RfY291bnQgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWNfMiAvLyAicGxvdF9jb3VudCIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3QucHk6MjExCiAgICAvLyBwbG90X2NvdW50X2FzX3N0cmluZyA9IGl0b2Eoc2VsZi5wbG90X2NvdW50KQogICAgY2FsbHN1YiBpdG9hCiAgICBkdXAKICAgIGJ1cnkgOQogICAgLy8gY29udHJhY3QucHk6MjEyCiAgICAvLyBwbG90X2NvdW50X3dpdGhfY29tbWFzID0gQnl0ZXMoYicnKQogICAgYnl0ZWNfMyAvLyAweAogICAgYnVyeSA4CiAgICAvLyBjb250cmFjdC5weToyMTQKICAgIC8vIGlmIHBsb3RfY291bnRfYXNfc3RyaW5nLmxlbmd0aCA8PSAzOgogICAgbGVuCiAgICBkdXAKICAgIGJ1cnkgNQogICAgaW50Y18yIC8vIDMKICAgIDw9CiAgICBieiBtaW50X3Bsb3RfZWxzZV9ib2R5QDMKICAgIGRpZyA3CiAgICBidXJ5IDcKCm1pbnRfcGxvdF9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gY29udHJhY3QucHk6MjI1LTIzNAogICAgLy8gY3JlYXRlX25leHRfdXNlcnNfcGxvdCA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgYXNzZXRfbmFtZT1iJ1Bsb3QgIzogJyArIHBsb3RfY291bnRfd2l0aF9jb21tYXMsCiAgICAvLyAgICAgdW5pdF9uYW1lPSdQTE9UJywKICAgIC8vICAgICB0b3RhbD0xLAogICAgLy8gICAgIGRlY2ltYWxzPTAsCiAgICAvLyAgICAgbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlc2VydmU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1UcnVlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gY29udHJhY3QucHk6MjI2CiAgICAvLyBhc3NldF9uYW1lPWInUGxvdCAjOiAnICsgcGxvdF9jb3VudF93aXRoX2NvbW1hcywKICAgIGJ5dGVjIDEzIC8vIDB4NTA2YzZmNzQyMDIzM2EyMAogICAgZGlnIDcKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3QucHk6MjMwCiAgICAvLyBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gY29udHJhY3QucHk6MjMxLTIzMgogICAgLy8gcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gZnJlZXplPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDIKICAgIC8vIGNvbnRyYWN0LnB5OjIzMwogICAgLy8gZGVmYXVsdF9mcm96ZW49VHJ1ZSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldEZyZWV6ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFJlc2VydmUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCiAgICAvLyBjb250cmFjdC5weToyMjkKICAgIC8vIGRlY2ltYWxzPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlY2ltYWxzCiAgICAvLyBjb250cmFjdC5weToyMjgKICAgIC8vIHRvdGFsPTEsCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCiAgICAvLyBjb250cmFjdC5weToyMjcKICAgIC8vIHVuaXRfbmFtZT0nUExPVCcsCiAgICBieXRlYyAxNCAvLyAiUExPVCIKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKICAgIC8vIGNvbnRyYWN0LnB5OjIyNQogICAgLy8gY3JlYXRlX25leHRfdXNlcnNfcGxvdCA9IGl0eG4uQXNzZXRDb25maWcoCiAgICBpbnRjXzIgLy8gYWNmZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToyMjUtMjM0CiAgICAvLyBjcmVhdGVfbmV4dF91c2Vyc19wbG90ID0gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICBhc3NldF9uYW1lPWInUGxvdCAjOiAnICsgcGxvdF9jb3VudF93aXRoX2NvbW1hcywKICAgIC8vICAgICB1bml0X25hbWU9J1BMT1QnLAogICAgLy8gICAgIHRvdGFsPTEsCiAgICAvLyAgICAgZGVjaW1hbHM9MCwKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPVRydWUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBDcmVhdGVkQXNzZXRJRAogICAgLy8gY29udHJhY3QucHk6MjM2CiAgICAvLyBzZWxmLnVuZnJlZXplX2Fzc2V0KHNlbGYubmV4dF9wbG90LCBUeG4uc2VuZGVyKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gIm5leHRfcGxvdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5uZXh0X3Bsb3QgZXhpc3RzCiAgICB0eG4gU2VuZGVyCiAgICAvLyBjb250cmFjdC5weToyNzQtMjc4CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hY2NvdW50PXRhcmdldCwKICAgIC8vICAgICBmcmVlemVfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgZnJvemVuPUZhbHNlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gY29udHJhY3QucHk6Mjc3CiAgICAvLyBmcm96ZW49RmFsc2UsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGcmVlemVBc3NldEZyb3plbgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXQKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXRBY2NvdW50CiAgICAvLyBjb250cmFjdC5weToyNzQKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICBwdXNoaW50IDUgLy8gYWZyegogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToyNzQtMjc4CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hY2NvdW50PXRhcmdldCwKICAgIC8vICAgICBmcmVlemVfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgZnJvemVuPUZhbHNlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIGNvbnRyYWN0LnB5OjIzNy0yNDEKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MSwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIHhmZXJfYXNzZXQ9c2VsZi5uZXh0X3Bsb3QsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBjb250cmFjdC5weToyMzkKICAgIC8vIGFzc2V0X3JlY2VpdmVyPVR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gY29udHJhY3QucHk6MjM4CiAgICAvLyBhc3NldF9hbW91bnQ9MSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICAvLyBjb250cmFjdC5weToyMzcKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMyAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToyMzctMjQxCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTEsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICB4ZmVyX2Fzc2V0PXNlbGYubmV4dF9wbG90LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIGNvbnRyYWN0LnB5OjI0MgogICAgLy8gc2VsZi5mcmVlemVfYXNzZXQoc2VsZi5uZXh0X3Bsb3QsIFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBjb250cmFjdC5weToyODItMjg2CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hY2NvdW50PXRhcmdldCwKICAgIC8vICAgICBmcmVlemVfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgZnJvemVuPVRydWUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBjb250cmFjdC5weToyODUKICAgIC8vIGZyb3plbj1UcnVlLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXRGcm96ZW4KICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXRBY2NvdW50CiAgICBpdHhuX2ZpZWxkIEZyZWV6ZUFzc2V0CiAgICAvLyBjb250cmFjdC5weToyODIKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICBwdXNoaW50IDUgLy8gYWZyegogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weToyODItMjg2CiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hY2NvdW50PXRhcmdldCwKICAgIC8vICAgICBmcmVlemVfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgZnJvemVuPVRydWUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gY29udHJhY3QucHk6MjQ0CiAgICAvLyBzZWxmLm5leHRfcGxvdCA9IGNyZWF0ZV9uZXh0X3VzZXJzX3Bsb3QuY3JlYXRlZF9hc3NldC5pZAogICAgYnl0ZWNfMSAvLyAibmV4dF9wbG90IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0LnB5OjExCiAgICAvLyByZXR1cm4gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBjb250cmFjdC5weToyNDcKICAgIC8vIHJlZnVuZF9leGNlc3NfbWJyKHByZV9tYnIsIHBvc3RfbWJyLCBtYnJfcGF5bWVudCkKICAgIGRpZyAyCiAgICBzd2FwCiAgICBkaWcgNAogICAgY2FsbHN1YiByZWZ1bmRfZXhjZXNzX21icgogICAgLy8gY29udHJhY3QucHk6MTk4CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptaW50X3Bsb3RfZWxzZV9ib2R5QDM6CiAgICAvLyBjb250cmFjdC5weToyMTcKICAgIC8vIGN1cnNvciA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgNgogICAgLy8gY29udHJhY3QucHk6MjE4CiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UocGxvdF9jb3VudF9hc19zdHJpbmcubGVuZ3RoKToKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDUKCm1pbnRfcGxvdF9mb3JfaGVhZGVyQDQ6CiAgICAvLyBjb250cmFjdC5weToyMTgKICAgIC8vIGZvciBpIGluIHVyYW5nZShwbG90X2NvdW50X2FzX3N0cmluZy5sZW5ndGgpOgogICAgZGlnIDQKICAgIGRpZyA0CiAgICA8CiAgICBieiBtaW50X3Bsb3RfYWZ0ZXJfaWZfZWxzZUAxMAogICAgLy8gY29udHJhY3QucHk6MjE5CiAgICAvLyBjdXJzb3IgKz0gMQogICAgZGlnIDUKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBkdXAKICAgIGJ1cnkgNwogICAgLy8gY29udHJhY3QucHk6MjIwCiAgICAvLyBpZiBjdXJzb3IgPT0gMzoKICAgIGludGNfMiAvLyAzCiAgICA9PQogICAgYnogbWludF9wbG90X2FmdGVyX2lmX2Vsc2VANwogICAgLy8gY29udHJhY3QucHk6MjIxCiAgICAvLyBwbG90X2NvdW50X3dpdGhfY29tbWFzID0gcGxvdF9jb3VudF93aXRoX2NvbW1hcyArIGInLCcKICAgIGRpZyA2CiAgICBwdXNoYnl0ZXMgMHgyYwogICAgY29uY2F0CiAgICBidXJ5IDcKICAgIC8vIGNvbnRyYWN0LnB5OjIyMgogICAgLy8gY3Vyc29yID0gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA2CgptaW50X3Bsb3RfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gY29udHJhY3QucHk6MjIzCiAgICAvLyBwbG90X2NvdW50X3dpdGhfY29tbWFzID0gcGxvdF9jb3VudF93aXRoX2NvbW1hcyArIHBsb3RfY291bnRfYXNfc3RyaW5nW2ldCiAgICBkaWcgNwogICAgZGlnIDUKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3QzCiAgICBkaWcgOAogICAgc3dhcAogICAgY29uY2F0CiAgICBidXJ5IDgKICAgIC8vIGNvbnRyYWN0LnB5OjIxOAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHBsb3RfY291bnRfYXNfc3RyaW5nLmxlbmd0aCk6CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSA1CiAgICBiIG1pbnRfcGxvdF9mb3JfaGVhZGVyQDQKCm1pbnRfcGxvdF9lbHNlX2JvZHlAMTk6CiAgICAvLyBjb250cmFjdC5weToyNjkKICAgIC8vIHVzZXJzX3Bsb3RzLmNyZWF0ZShzaXplPVVJbnQ2NCgyNikpCiAgICBkdXAKICAgIHB1c2hpbnQgMjYgLy8gMjYKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gY29udHJhY3QucHk6MjcwCiAgICAvLyB1c2Vyc19wbG90cy5yZXBsYWNlKDAsIHBsb3RfaW5mby5ieXRlcykKICAgIGludGNfMCAvLyAwCiAgICBkaWcgMgogICAgYm94X3JlcGxhY2UKICAgIGIgbWludF9wbG90X2FmdGVyX2lmX2Vsc2VAMjAKCgovLyBjb250cmFjdC5FY28uY2xhaW1fcGxvdF9yZXdhcmRzW3JvdXRpbmddKCkgLT4gdm9pZDoKY2xhaW1fcGxvdF9yZXdhcmRzOgogICAgLy8gY29udHJhY3QucHk6MzExCiAgICAvLyB0b3RhbF9yZXdhcmQgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdC5weTozMTIKICAgIC8vIHVzZXJzX3Bsb3RzID0gQm94KEJ5dGVzLCBrZXk9YidwJyArIFR4bi5zZW5kZXIuYnl0ZXMpICMgcCBwcmVmaXggZm9yIHBsb3RzCiAgICBwdXNoYnl0ZXMgMHg3MAogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIGNvbnRyYWN0LnB5OjMxMwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHVzZXJzX3Bsb3RzLmxlbmd0aCAvLyAyNik6CiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgQm94IGV4aXN0cwogICAgcHVzaGludCAyNiAvLyAyNgogICAgLwogICAgaW50Y18wIC8vIDAKCmNsYWltX3Bsb3RfcmV3YXJkc19mb3JfaGVhZGVyQDI6CiAgICAvLyBjb250cmFjdC5weTozMTMKICAgIC8vIGZvciBpIGluIHVyYW5nZSh1c2Vyc19wbG90cy5sZW5ndGggLy8gMjYpOgogICAgZHVwCiAgICBkaWcgMgogICAgPAogICAgYnogY2xhaW1fcGxvdF9yZXdhcmRzX2FmdGVyX2ZvckA0CiAgICAvLyBjb250cmFjdC5weTozMTQKICAgIC8vIGluZGl2aWR1YWxfcGxvdF9ieXRlcyA9IHVzZXJzX3Bsb3RzLmV4dHJhY3QoaSwgaSArIDI2KQogICAgZHVwbiAyCiAgICBwdXNoaW50IDI2IC8vIDI2CiAgICArCiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkaWcgMgogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gY29udHJhY3QucHk6MzE2CiAgICAvLyBwbG90X3Jld2FyZCA9IChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCAtIHBsb3RfaW5mby5wbG90X2xhc3RfY2xhaW1fdGltZS5hc191aW50NjQoKSkgKiBzZWxmLnBsb3RfcmV3YXJkX3JhdGUKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIHN3YXAKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gInBsb3RfcmV3YXJkX3JhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucGxvdF9yZXdhcmRfcmF0ZSBleGlzdHMKICAgICoKICAgIC8vIGNvbnRyYWN0LnB5OjMxNwogICAgLy8gdG90YWxfcmV3YXJkICs9IHBsb3RfcmV3YXJkCiAgICBkaWcgNgogICAgKwogICAgYnVyeSA2CiAgICAvLyBjb250cmFjdC5weTozMTgKICAgIC8vIHVzZXJzX3Bsb3RzLnNwbGljZShpICsgOCwgOCwgYXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApLmJ5dGVzKQogICAgZHVwCiAgICBwdXNoaW50IDggLy8gOAogICAgKwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICB1bmNvdmVyIDMKICAgIGJveF9zcGxpY2UKICAgIC8vIGNvbnRyYWN0LnB5OjMxMwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHVzZXJzX3Bsb3RzLmxlbmd0aCAvLyAyNik6CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxCiAgICBiIGNsYWltX3Bsb3RfcmV3YXJkc19mb3JfaGVhZGVyQDIKCmNsYWltX3Bsb3RfcmV3YXJkc19hZnRlcl9mb3JANDoKICAgIC8vIGNvbnRyYWN0LnB5OjMyMy0zMjcKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PXNlbGYuZWNvX3Rva2VuLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1yZXdhcmRfYW1vdW50LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPVR4bi5zZW5kZXIKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGNvbnRyYWN0LnB5OjMyNAogICAgLy8geGZlcl9hc3NldD1zZWxmLmVjb190b2tlbiwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlY29fdG9rZW4iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZWNvX3Rva2VuIGV4aXN0cwogICAgLy8gY29udHJhY3QucHk6MzI2CiAgICAvLyBhc3NldF9yZWNlaXZlcj1UeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGRpZyA0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBjb250cmFjdC5weTozMjMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMyAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBjb250cmFjdC5weTozMjMtMzI3CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1zZWxmLmVjb190b2tlbiwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9cmV3YXJkX2Ftb3VudCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1UeG4uc2VuZGVyCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gY29udHJhY3QucHk6MzAzCiAgICAvLyBAYWJpbWV0aG9kCiAgICBpdG9iCiAgICBieXRlYyAxMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [326], "errorMessage": "OnCompletion must be NoOp"}, {"pc": [373], "errorMessage": "OnCompletion must be NoOp && can only call when creating"}, {"pc": [521, 572, 613, 909, 1040, 1230], "errorMessage": "account funded"}, {"pc": [1076, 1321], "errorMessage": "check Box exists"}, {"pc": [581, 660, 1393], "errorMessage": "check self.eco_token exists"}, {"pc": [1060], "errorMessage": "check self.empty_plot_items exists"}, {"pc": [1051, 1165], "errorMessage": "check self.next_plot exists"}, {"pc": [1033], "errorMessage": "check self.plot_cost exists"}, {"pc": [845, 1093], "errorMessage": "check self.plot_count exists"}, {"pc": [1359], "errorMessage": "check self.plot_reward_rate exists"}, {"pc": [618], "errorMessage": "check self.pool_logicsig_template exists"}, {"pc": [650], "errorMessage": "check self.tinyman_router exists"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class MintEcoArgs:
    """Dataclass for mint_eco arguments"""
    mbr_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "mint_eco(txn)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class BootstrapViaOuterAndAddInitialLiquidityArgs:
    """Dataclass for bootstrap_via_outer_and_add_initial_liquidity arguments"""
    mbr_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "bootstrap_via_outer_and_add_initial_liquidity(txn)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class MintPlotArgs:
    """Dataclass for mint_plot arguments"""
    plot_payment: algokit_utils.AppMethodCallTransactionArgument | None = None
    mbr_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "mint_plot(txn,txn)void"


class EcoParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def mint_eco(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | MintEcoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_eco(txn)uint64",
            "args": method_args,
        }))

    def bootstrap_via_outer_and_add_initial_liquidity(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | BootstrapViaOuterAndAddInitialLiquidityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "bootstrap_via_outer_and_add_initial_liquidity(txn)void",
            "args": method_args,
        }))

    def mint_plot(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | MintPlotArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_plot(txn,txn)void",
            "args": method_args,
        }))

    def claim_plot_rewards(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_plot_rewards()uint64",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class EcoCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def mint_eco(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | MintEcoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_eco(txn)uint64",
            "args": method_args,
        }))

    def bootstrap_via_outer_and_add_initial_liquidity(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | BootstrapViaOuterAndAddInitialLiquidityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "bootstrap_via_outer_and_add_initial_liquidity(txn)void",
            "args": method_args,
        }))

    def mint_plot(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | MintPlotArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_plot(txn,txn)void",
            "args": method_args,
        }))

    def claim_plot_rewards(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_plot_rewards()uint64",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class EcoSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def mint_eco(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | MintEcoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_eco(txn)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def bootstrap_via_outer_and_add_initial_liquidity(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | BootstrapViaOuterAndAddInitialLiquidityArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "bootstrap_via_outer_and_add_initial_liquidity(txn)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def mint_plot(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | MintPlotArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "mint_plot(txn,txn)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def claim_plot_rewards(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "claim_plot_rewards()uint64",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    eco_token: int
    eco_token_created: int
    eco_lp_token: int
    plot_count: int
    next_plot: int
    plot_cost: int
    plot_reward_rate: int
    pool_logicsig_template: bytes
    tinyman_router: int
    empty_plot_items: bytes

class EcoState:
    """Methods to access state for the current Eco app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def eco_token(self) -> int:
        """Get the current value of the eco_token key in global_state state"""
        value = self.app_client.state.global_state.get_value("eco_token")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def eco_token_created(self) -> int:
        """Get the current value of the eco_token_created key in global_state state"""
        value = self.app_client.state.global_state.get_value("eco_token_created")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def eco_lp_token(self) -> int:
        """Get the current value of the eco_lp_token key in global_state state"""
        value = self.app_client.state.global_state.get_value("eco_lp_token")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def plot_count(self) -> int:
        """Get the current value of the plot_count key in global_state state"""
        value = self.app_client.state.global_state.get_value("plot_count")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def next_plot(self) -> int:
        """Get the current value of the next_plot key in global_state state"""
        value = self.app_client.state.global_state.get_value("next_plot")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def plot_cost(self) -> int:
        """Get the current value of the plot_cost key in global_state state"""
        value = self.app_client.state.global_state.get_value("plot_cost")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def plot_reward_rate(self) -> int:
        """Get the current value of the plot_reward_rate key in global_state state"""
        value = self.app_client.state.global_state.get_value("plot_reward_rate")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def pool_logicsig_template(self) -> bytes:
        """Get the current value of the pool_logicsig_template key in global_state state"""
        value = self.app_client.state.global_state.get_value("pool_logicsig_template")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def tinyman_router(self) -> int:
        """Get the current value of the tinyman_router key in global_state state"""
        value = self.app_client.state.global_state.get_value("tinyman_router")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def empty_plot_items(self) -> bytes:
        """Get the current value of the empty_plot_items key in global_state state"""
        value = self.app_client.state.global_state.get_value("empty_plot_items")
        if isinstance(value, dict) and "byte[10]" in self._struct_classes:
            return _init_dataclass(self._struct_classes["byte[10]"], value)  # type: ignore
        return typing.cast(bytes, value)

class EcoClient:
    """Client for interacting with Eco smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = EcoParams(self.app_client)
        self.create_transaction = EcoCreateTransactionParams(self.app_client)
        self.send = EcoSend(self.app_client)
        self.state = EcoState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "EcoClient":
        return EcoClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "EcoClient":
        return EcoClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "EcoClient":
        return EcoClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "EcoComposer":
        return EcoComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["mint_eco(txn)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["bootstrap_via_outer_and_add_initial_liquidity(txn)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["mint_plot(txn,txn)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["claim_plot_rewards()uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class EcoBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating Eco contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class EcoFactory(algokit_utils.TypedAppFactoryProtocol[EcoBareCallCreateParams, None, None]):
    """Factory for deploying and managing EcoClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = EcoFactoryParams(self.app_factory)
        self.create_transaction = EcoFactoryCreateTransaction(self.app_factory)
        self.send = EcoFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: EcoBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[EcoClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return EcoClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> EcoClient:
        """Get an app client by creator address and name"""
        return EcoClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> EcoClient:
        """Get an app client by app ID"""
        return EcoClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class EcoFactoryParams:
    """Parameters for creating transactions for Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EcoFactoryCreateParams(app_factory)
        self.update = EcoFactoryUpdateParams(app_factory)
        self.delete = EcoFactoryDeleteParams(app_factory)

class EcoFactoryCreateParams:
    """Parameters for 'create' operations of Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def mint_eco(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | MintEcoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the mint_eco(txn)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "mint_eco(txn)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def bootstrap_via_outer_and_add_initial_liquidity(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | BootstrapViaOuterAndAddInitialLiquidityArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the bootstrap_via_outer_and_add_initial_liquidity(txn)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "bootstrap_via_outer_and_add_initial_liquidity(txn)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def mint_plot(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | MintPlotArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the mint_plot(txn,txn)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "mint_plot(txn,txn)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def claim_plot_rewards(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the claim_plot_rewards()uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "claim_plot_rewards()uint64",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class EcoFactoryUpdateParams:
    """Parameters for 'update' operations of Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class EcoFactoryDeleteParams:
    """Parameters for 'delete' operations of Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class EcoFactoryCreateTransaction:
    """Create transactions for Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EcoFactoryCreateTransactionCreate(app_factory)


class EcoFactoryCreateTransactionCreate:
    """Create new instances of Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class EcoFactorySend:
    """Send calls to Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EcoFactorySendCreate(app_factory)


class EcoFactorySendCreate:
    """Send create calls to Eco contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[EcoClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return EcoClient(result[0]), result[1]


class EcoComposer:
    """Composer for creating transaction groups for Eco contract calls"""

    def __init__(self, client: "EcoClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def mint_eco(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | MintEcoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EcoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.mint_eco(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "mint_eco(txn)uint64", v
            )
        )
        return self

    def bootstrap_via_outer_and_add_initial_liquidity(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | BootstrapViaOuterAndAddInitialLiquidityArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EcoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.bootstrap_via_outer_and_add_initial_liquidity(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "bootstrap_via_outer_and_add_initial_liquidity(txn)void", v
            )
        )
        return self

    def mint_plot(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | MintPlotArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EcoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.mint_plot(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "mint_plot(txn,txn)void", v
            )
        )
        return self

    def claim_plot_rewards(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EcoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.claim_plot_rewards(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "claim_plot_rewards()uint64", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "EcoComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "EcoComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
